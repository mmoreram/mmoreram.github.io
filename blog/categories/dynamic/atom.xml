<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dynamic | Because yes]]></title>
  <link href="http://mmoreram.github.io/blog/categories/dynamic/atom.xml" rel="self"/>
  <link href="http://mmoreram.github.io/"/>
  <updated>2014-05-15T17:54:46+02:00</updated>
  <id>http://mmoreram.github.io/</id>
  <author>
    <name><![CDATA[Marc Morera]]></name>
    <email><![CDATA[yuhu@mmoreram.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dynamic routes in Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2013/10/01/dynamic-routes-in-symfony2/"/>
    <updated>2013-10-01T18:30:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2013/10/01/dynamic-routes-in-symfony2</id>
    <content type="html"><![CDATA[<p>Given that most times we need to associate a static route entry with a method of
a controller, it is normal for Symfony developers are used to working with the
annotation @Route of FrameworkExtraBundle.</p>

<p>In some cases, it will be interesting or necessary to work with the router to
generate dynamic routes. This means that any bundle can generate a route from a
service, defining both the name of the route as all the information necessary
for the resolution of the route.</p>

<p>Consider the following example</p>

<p>``` php
&lt;?php</p>

<p>namespace Mmoreram\AcmeBundle\Router;</p>

<p>use Symfony\Component\Config\Loader\LoaderInterface;
use Symfony\Component\Config\Loader\LoaderResolverInterface;
use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\RouteCollection;</p>

<p>/<em>*
 * Acme dynamic router
 </em>/
class AcmeRoutesLoader implements LoaderInterface
{</p>

<pre><code>/**
 * @var boolean
 *
 * Route is loaded
 */
private $loaded = false;

/**
 * Loads a resource.
 *
 * @param mixed  $resource The resource
 * @param string $type     The resource type
 *
 * @return RouteCollection
 *
 * @throws RuntimeException Loader is added twice
 */
public function load($resource, $type = null)
{
    if ($this-&gt;loaded) {

        throw new \RuntimeException('Do not add this loader twice');
    }

    $routes = new RouteCollection();

    /**
     * url('controller_name') will point AcmeController:methodAction()
     */
    $routes-&gt;add('controller_name', new Route('controller/route', array(
        '_controller'   =&gt;  'AcmeBundle:Acme:method',
    )));

    $this-&gt;loaded = true;

    return $routes;
}

/**
 * Returns true if this class supports the given resource.
 *
 * @param mixed  $resource A resource
 * @param string $type     The resource type
 *
 * @return boolean This class supports the given resource
 */
public function supports($resource, $type = null)
{
    return 'acme' === $type;
}

/**
 * Gets the loader resolver.
 *
 * @return LoaderResolverInterface A LoaderResolverInterface instance
 */
public function getResolver()
{
}

/**
 * Sets the loader resolver.
 *
 * @param LoaderResolverInterface $resolver A LoaderResolverInterface
 */
public function setResolver(LoaderResolverInterface $resolver)
{
}
</code></pre>

<p>}
```</p>

<p>In method <code>supports()</code>, <code>$type</code> value can be any desired value, and only should
be defined once in all project.</p>

<p>As any service, we must define this class in dependency injection with specific
tag.</p>

<p>``` yml
services:</p>

<pre><code>acme.routes.loader:
    class: Mmoreram\AcmeBundle\Router\AcmeRoutesLoader
    tags:
        - { name: routing.loader }
</code></pre>

<p>```</p>

<p>And finally we just need to make our project know where to build our route, so
in <code>routing.yml</code> file we must add these lines.</p>

<p>``` yml
acme_routes:</p>

<pre><code>resource: .
type: acme
</code></pre>

<p>```</p>

<blockquote><p>At this point, type value must be the same as defined in Router service.</p></blockquote>
]]></content>
  </entry>
  
</feed>
