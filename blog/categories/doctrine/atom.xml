<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: doctrine | Because yes]]></title>
  <link href="http://mmoreram.github.io/blog/categories/doctrine/atom.xml" rel="self"/>
  <link href="http://mmoreram.github.io/"/>
  <updated>2014-10-15T16:17:53+02:00</updated>
  <id>http://mmoreram.github.io/</id>
  <author>
    <name><![CDATA[Marc Morera]]></name>
    <email><![CDATA[yuhu@mmoreram.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Flushing Doctrine2 entities]]></title>
    <link href="http://mmoreram.github.io/blog/2013/10/11/flushing-doctrine2-entities/"/>
    <updated>2013-10-11T10:11:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2013/10/11/flushing-doctrine2-entities</id>
    <content type="html"><![CDATA[<p>Given this example</p>

<p>``` php
$spain = new Country;
$spain->setName(&lsquo;spain&rsquo;);
$entityManager->persist($spain);</p>

<p>$france = new Country;
$france->setName(&lsquo;france&rsquo;);
$entityManager->persist($france);</p>

<p>$entityManager->flush();
```</p>

<p>When we flush without defining any kind of parameter, all entities managed by
EntityManager with changes will be flushed.<br/>
To flush a specific entity managed by EntityManager we can just pass the entity
as a parameter in the flush method</p>

<p>``` php
$spain = new Country;
$spain->setName(&lsquo;spain&rsquo;);
$entityManager->persist($spain);</p>

<p>$france = new Country;
$france->setName(&lsquo;france&rsquo;);
$entityManager->persist($france);</p>

<p>/<em>*
 * At this point, I only want to flush $spain
 </em>/
$entityManager->flush($spain);
```</p>

<p>To flush an array of entities managed by EntityManager we can pass the array as
a parameter in the flush method</p>

<p>``` php
$spain = new Country;
$spain->setName(&lsquo;spain&rsquo;);
$entityManager->persist($spain);</p>

<p>$france = new Country;
$france->setName(&lsquo;france&rsquo;);
$entityManager->persist($france);</p>

<p>$germany = new Country;
$germany->setName(&lsquo;germany&rsquo;);
$entityManager->persist($germany);</p>

<p>/<em>*
 * At this point, I only want to flush $spain
 </em>/
$entityManager->flush(array(</p>

<pre><code>$spain,
$france,
</code></pre>

<p>));
```</p>

<p>So, how about flushing an ArrayCollection of entities? Lets take a look at the
UnitOfWork code where contains this logic.</p>

<p>``` php
if ($entity === null) {</p>

<pre><code>$this-&gt;computeChangeSets();
</code></pre>

<p>} elseif (is_object($entity)) {</p>

<pre><code>$this-&gt;computeSingleEntityChangeSet($entity);
</code></pre>

<p>} elseif (is_array($entity)) {</p>

<pre><code>foreach ($entity as $object) {
    $this-&gt;computeSingleEntityChangeSet($object);
}
</code></pre>

<p>}
```</p>

<p>Considering that ArrayCollection is an object, this code should be changed to
this code to also accept ArrayCollection and all iterable objects.</p>

<p>``` php
if ($entity === null) {</p>

<pre><code>$this-&gt;computeChangeSets();
</code></pre>

<p>} elseif (is_array($entity) || $entity instanceof IteratorAggregate) {</p>

<pre><code>foreach ($entity as $object) {
    $this-&gt;computeSingleEntityChangeSet($object);
}
</code></pre>

<p>} elseif (is_object($entity)) {</p>

<pre><code>$this-&gt;computeSingleEntityChangeSet($entity);
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inverse associations in Doctrine2 models]]></title>
    <link href="http://mmoreram.github.io/blog/2013/10/09/inverse-associations-in-doctrine2-models/"/>
    <updated>2013-10-09T11:37:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2013/10/09/inverse-associations-in-doctrine2-models</id>
    <content type="html"><![CDATA[<p>Lets take a look some basic example about simple Doctrine2 relation.</p>

<p>``` php
/<em>*
 * Country
 *
 * @ORM\Entity
 * @ORM\Table(name=&ldquo;countries&rdquo;)
 </em>/
class Country {</p>

<pre><code>/**
 * @var ArrayCollection
 *
 * @ORM\OneToMany(targetEntity="Province", mappedBy="country")
 */
protected $provinces;

/**
 * Constructor
 */
public function __construct()
{
    $this-&gt;provinces = new ArrayCollection;
}

/**
 * Add province
 *
 * @param Province $province Province to add
 *
 * @return Country self Object
 */
public function addProvince()
{
    $this-&gt;provinces[] = $province;

    return $this;
}
</code></pre>

<p>}
```</p>

<p>``` php
/<em>*
 * Province
 *
 * @ORM\Entity
 * @ORM\Table(name=&ldquo;provinces&rdquo;)
 </em>/
class Province {</p>

<pre><code>/**
 * @var Country
 *
 * @ORM\ManyToOne(targetEntity="Country", inversedBy="provinces")
 * @ORM\JoinColumn(name="country_id", referencedColumnName="id", nullable=false)
 */
protected $country;

/**
 * Set Country
 *
 * @param Country $country Country
 *
 * @return Province self Object
 */
public function setCountry(Country $country)
{
    $this-&gt;country = $country;

    return $this;
}

/**
 * Get the country
 *
 * @return Country
 */
public function getCountry()
{
    return $this-&gt;country;
}
</code></pre>

<p>}
```</p>

<p>The reason for this post is to try to understand the direct impact of making an
inversed relationship when we allocate a new province in a country.
Given the model we have in the first instance, and given this piece of
controller</p>

<p>``` php
$country = $this</p>

<pre><code>-&gt;entityManager
-&gt;getRepository('AcmeCoreBundle:Country')
-&gt;findBy(1);
</code></pre>

<p>$province = new Province();
$province->setCountry($country);
$this->entityManager->persist($province);
$this->entityManager->flush();
```</p>

<p>In this case, when we assign the Country to the new Province, and given that the
owning side of the association is Province, when you flush, the association
persists in database, so that in future reference, we would have the desired
results.<br/>
The &ldquo;problem&rdquo; exists because our <code>EntityManager</code> works with internal cache.
If after this assignment, and in the same request, we need to return all the
provinces of the Country, in particular the Country with id 1, the returned
collection will not contain the new Province if this data is already cached.
This is because we have not perfomed reversed assignment. There are two ways of
solving this.</p>

<h3>Model owns the responsability of double assignment</h3>

<p>We can resolve this giving model the responsability of double assignment.</p>

<p>``` php
/<em>*
 * Province
 *
 * @ORM\Entity
 * @ORM\Table(name=&ldquo;provinces&rdquo;)
 </em>/
class Province {</p>

<pre><code>/**
 * @var Country
 *
 * @ORM\ManyToOne(targetEntity="Country", inversedBy="provinces")
 * @ORM\JoinColumn(name="country_id", referencedColumnName="id", nullable=false)
 */
protected $country;

/**
 * Set Country
 *
 * @param Country $country Country
 *
 * @return Province self Object
 */
public function setCountry(Country $country)
{
    $this-&gt;country = $country;

    /**
     * We perform inversed assignment
     */
    $country-&gt;setProvince($this);

    return $this;
}

/**
 * Get the country
 *
 * @return Country
 */
public function getCountry()
{
    return $this-&gt;country;
}
</code></pre>

<p>}
```</p>

<p>This has a good side and bad. On the one hand, is a completely transparent
process so that the model handles internally to manage their relationships.
It allows the driver to disengage completely from the model.
On the other hand, we must bear in mind that <strong>will</strong> always done this inverse
relationship. This can be a plus for a project, unless handled very large
amounts of data.<br/>
To give an example, we can imagine a Country with a million provinces.
When charging Country in memory, while not run the <code>getProvinces ()</code> and since
we work with lazy loading, we will have no memory problem. The problem comes
when you add a new province to Country. As a collection, to add an item,
doctrine do something like <code>getProvinces()</code> and then make
`$provinces[] = $province;&lsquo;.  Keep in mind that loading in memory up to 1
million entities without any need is a non desired behaviour.</p>

<h3>Controller ( each one ) owns the responsability of double assignment</h3>

<p>In this case, controller need to perform inversed assignment.</p>

<p>``` php
$country = $this</p>

<pre><code>-&gt;entityManager
-&gt;getRepository('AcmeCoreBundle:Country')
-&gt;findBy(1);
</code></pre>

<p>$province = new Province();
$province->setCountry($country);
$country->addProvince($province);
$this->entityManager->persist($province);
$this->entityManager->flush();
```</p>

<p>You will choose if is the best option, so you have an idea about if all
provinces are used later. If are used and a million Provinces are loaded,
you will have the same problem as first case, but has nothing to do about
this&hellip;</p>

<p>My conclusion would be something like &hellip; Know your model and scope, and give
responsibilities accordingly.</p>

<p>What do you think?</p>
]]></content>
  </entry>
  
</feed>
