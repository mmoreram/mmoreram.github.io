<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Symfony | Because yes]]></title>
  <link href="http://mmoreram.com/blog/categories/symfony/atom.xml" rel="self"/>
  <link href="http://mmoreram.com/"/>
  <updated>2017-01-27T01:03:58+01:00</updated>
  <id>http://mmoreram.com/</id>
  <author>
    <name><![CDATA[Marc Morera]]></name>
    <email><![CDATA[yuhu@mmoreram.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Re-thinking Event Listeners]]></title>
    <link href="http://mmoreram.com/blog/2015/08/20/re-thinking-event-listeners/"/>
    <updated>2015-08-20T12:27:00+02:00</updated>
    <id>http://mmoreram.com/blog/2015/08/20/re-thinking-event-listeners</id>
    <content type="html"><![CDATA[<p>Let&rsquo;s talk about Event Listeners.
Do you know what an Event Listener is?</p>

<p>Well, if you are used to working with Symfony, then you should know what is
intended for. If you don&rsquo;t, don&rsquo;t hesitate to take a look at the Symfony
documentation.</p>

<p>This post aims to start a small discussion about how an Event Listener should
look like if we really want to keep things decoupled.</p>

<h2>TL;DR</h2>

<ul>
<li>If we place our business logic inside the Event Listeners, we will not be able
to use this logic from other points, for example sending a &ldquo;Order created&rdquo; email
by hand from our Admin using a simple button.</li>
<li>What we could do is place ALL the logic inside a service that ONLY sends that
email, exposing a simple and documented api.</li>
<li>Then, considering that this service is injectable using any Dependency
Injection implementation, we can inject it into the Event Listener.</li>
<li>So, EventListeners are only a point of entry to your service layer</li>
</ul>


<h2>Using Event Listeners</h2>

<p>To understand what I am talking about, let&rsquo;s use an small example to make things
more clear&hellip;</p>

<p>```
Scenario: You buy something in an e-commerce, so, internally, your Cart became
an Order. Of course, and because user experience is important in that cases, you
want to send an email to the user with some Order information, so you need to
send an email to the Customer.</p>

<p>Problem: You want to create this feature in a very decoupled way, of course. The
e-commerce framework provides you that way, by proposing you an event once the
Order is created. You can access the Order itself and the Customer.</p>

<p>Solution: Create a new Event Listener object, subscribed to this event called
order.oncreate, and sending that email.
```</p>

<p>Let&rsquo;s see a small example about how this Event Listener should look like. We
will follow the simple way, only focusing about sending that email in a
decoupled way with the action.</p>

<p>``` php
class OrderEmailEventListener
{</p>

<pre><code>/**
 * We send an email to the Customer once an order is created
 *
 * @param OrderOnCreatedEvent $event Event
 */
public function sendEmail(OrderOnCreatedEvent $event)
{
    $order = $event-&gt;getOrder();
    $customer = $event-&gt;getCustomer();

    /**
     * Send the email
     */
}
</code></pre>

<p>}
```</p>

<p>And we could use this configuration in our bundle.</p>

<p>``` yaml
services:</p>

<pre><code>#
# Event Listeners
#
project.event_listener.order_created_email:
    class: My\Bundle\EventListener\OrderCreatedEmailEventListener
    tags:
        - { name: kernel.event_listener, event: order.oncreate, method: sendEmail }
</code></pre>

<p>```</p>

<p>So this could be a simple implementation. I&rsquo;ve been using it since the beginning
of times as this could be considered a good practice. But, during this time
doing more and more Event Listeners, some questions have come to my mind.</p>

<h2>Decoupling from the Event</h2>

<p>Let&rsquo;s consider that our project has an admin panel. Of course, we should be able
to send this email any time we need (for example, our email server was down
during the order conversion and we must re-send it). Is this possible with this
implementation?</p>

<p>Yes. Let&rsquo;s do this considering that we have injected our EventListener and this
one is accessible locally!</p>

<p>```php
$event = new OrderCreatedEmailEventListener(</p>

<pre><code>$order,
$customer
</code></pre>

<p>);
$orderCreatedEmailEventListener->sendEmail($event);
```</p>

<p>Well, this piece of code will really send the email&hellip; but is this
implementation enough right? I don&rsquo;t think so&hellip;</p>

<p>This Event should only be dispatched when the real event happens. It has no
sense to create a new <code>OrderEmailEventListener</code> instance without using the
event dispatcher. This means that, indeed, any Order has been created.</p>

<p>So first of all, creating a new Event out of turn, is not a good practice at
all.</p>

<p>For solving this, We could do that.</p>

<p>``` php
class OrderCreatedEmailEventListener
{</p>

<pre><code>/**
 * We send an email to the Customer once an order is created
 *
 * @param OrderOnCreatedEvent $event Event
 */
public function sendEmail(OrderOnCreatedEvent $event)
{
    $order = $event-&gt;getOrder();
    $customer = $event-&gt;getCustomer();

    $this-&gt;sendOrderCreatedEmail(
        $order,
        $customer
    );
}

/**
 * We send an email to the Customer once an order is created, given the 
 * order and the customer
 *
 * @param OrderInterface    $order    Order
 * @param CustomerInterface $customer Customer
 */
public function sendOrderCreatedEmail(
    OrderInterface $order,
    CustomerInterface $customer
) {
    /**
     * Send the email
     */
}
</code></pre>

<p>}
```</p>

<p>And then, we could do this</p>

<p>```php
$orderCreatedEmailEventListener->sendOrderCreatedEmail(</p>

<pre><code>$order,
$customer
</code></pre>

<p>);
```</p>

<p>Much better, right?
But is this good enough? No is not.</p>

<h2>Decoupling from the Listener</h2>

<p>We are using an instance of an Event Listener to send an email. Our analysis
could be exactly the same than before&hellip; Should we use an Event Listener even
when an event is not dispatched?</p>

<p>No we should not.</p>

<p>An Event Listener is an event listener. Listens one event, and that should be
all its work. So, we should never inject any event listener, anywhere. Let&rsquo;s do
some refactor here!</p>

<p>First of all, let&rsquo;s isolate our business logic in a new service. This service
will <strong>only</strong> do one thing; sending this email.</p>

<p>``` php
class OrderCreatedEmailSender
{</p>

<pre><code>/**
 * We send an email to the Customer once an order is created, given the 
 * order and the customer
 *
 * @param OrderInterface    $order    Order
 * @param CustomerInterface $customer Customer
 */
public function sendEmail(
    OrderInterface $order,
    CustomerInterface $customer
) {
    /**
     * Send the email
     */
}
</code></pre>

<p>}
```</p>

<p>This service has only one mission. Sending this email, no matter what event
executes it, no matter its environment. So if we take a look at what the Event
Listener implementation should look like now&hellip;</p>

<p>``` php
class OrderCreatedEmailEventListener
{</p>

<pre><code>/**
 * @var OrderCreatedEmailSender
 *
 * Order created email sender
 */
private $orderCreatedEmailSender;

/**
 * Constructor
 *
 * @param OrderCreatedEmailSender $orderCreatedEmailSender
 */
public function __construct(OrderCreatedEmailSender $orderCreatedEmailSender)
{
    $this-&gt;orderCreatedEmailSender = $orderCreatedEmailSender;
}

/**
 * We send an email to the Customer once an order is created
 *
 * @param OrderOnCreatedEvent $event Event
 */
public function sendEmail(OrderOnCreatedEvent $event)
{
    $order = $event-&gt;getOrder();
    $customer = $event-&gt;getCustomer();

    $this
        -&gt;orderCreatedEmailSender
        -&gt;sendEmail(
            $order,
            $customer
        );
}
</code></pre>

<p>}
```</p>

<p>Finally, we should refactor as well the way we have defined our service in the
DependencyInjection config file.</p>

<p>``` yaml
services:</p>

<pre><code>#
# Business layer
#
project.business.order_created_email_sender:
    class: My\Bundle\Business\OrderCreatedEmailSender

#
# Event Listeners
#
project.event_listener.order_created_email:
    class: My\Bundle\EventListener\OrderCreatedEmailEventListener
    arguments:
        - @project.business.order_created_email_sender
    tags:
        - { name: kernel.event_listener, event: order.oncreate, method: sendEmail }
</code></pre>

<p>```</p>

<p>And that&rsquo;s all.
This example is so easy and simple, but I am sure that if you take a look at
your project, you will find a lot of logic inside your Event Listeners. Maybe
could be a good idea start moving all this logic out of the box, treating these
listeners as real entry points, like we do with our Commands, Controllers or
Twig extensions.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Defeating Expression Language]]></title>
    <link href="http://mmoreram.com/blog/2015/05/18/defeating-expression-language/"/>
    <updated>2015-05-18T09:53:00+02:00</updated>
    <id>http://mmoreram.com/blog/2015/05/18/defeating-expression-language</id>
    <content type="html"><![CDATA[<p>How beautiful Expression Language definitions are, right? I mean, inserting that
complex expressions in a Dependency Injection configuration file is so nice and
fast if you need to inject the result of a method in a service (one of the
multiple examples we can see)</p>

<p>Let&rsquo;s see a simple example of how we use this library.</p>

<p>``` yaml
services:</p>

<pre><code>#
# My managers
#
some_manager:
    class: This\Is\My\Manager
    arguments:
        - @=service("another_manager").someCall("value")
        - @=service("yet_another_manager").getInjectableInstance(parameter("my_parameter"))
</code></pre>

<p>```</p>

<p>This is not a bad idea, really, but because we are engineers and we should have
as much information as possible in order to be able to choose between the best
option, always, I will show you another way of defining this piece of code.</p>

<p>Let&rsquo;s do that!</p>

<h3>Factories</h3>

<p>Remember the <a href="http://mmoreram.com/blog/2013/12/23/factory-pattern-in-symfony2/">Factory pattern in Symfony2</a>
post I wrote some time ago? I talked about how this pattern can be implemented
in your Symfony projects.</p>

<p>Well, just for your information, most of your Expression Language definitions
can be nicely done using Factories.</p>

<p>Let&rsquo;s reproduce the same example using factories.</p>

<p>``` yaml
services:</p>

<pre><code>#
# My managers
#
some_manager:
    class: This\Is\My\Manager
    arguments:
        - @my_injectable_value
        - @my_injectable_service

my_injectable_value:
    class: StdClass
    factory: 
        - @another_manager
        - someCall
    arguments:
        - value

my_injectable_service:
    class: This\Is\My\Injectable\Class
    factory: 
        - @yet_another_manager
        - getInjectableInstance
    arguments:
        - %my_parameter%
</code></pre>

<p>```</p>

<h3>Dependency</h3>

<p>Take a look and realise that we&rsquo;ve removed a package dependency from your
project, as you don&rsquo;t need <code>symfony/expression-language</code> anymore, and your DIC
definition will be easily exportable to another format if someday is needed.</p>

<h3>Reflexion</h3>

<p>Is Expression Language a bad choice? Well, only you should be able to know if
using this library is a good choice or not, because only you know your needs and
your resources, but every time you add a new Expression Language line, just ask
yourself&hellip;</p>

<p>Can I use simple DI definitions here? Is the only way I can do that?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lazy Commands in Symfony]]></title>
    <link href="http://mmoreram.com/blog/2015/05/08/lazy-commands-in-symfony/"/>
    <updated>2015-05-08T11:04:00+02:00</updated>
    <id>http://mmoreram.com/blog/2015/05/08/lazy-commands-in-symfony</id>
    <content type="html"><![CDATA[<p>Have you ever had this scenario?</p>

<p>``` bash
$ php app/console doctrine:database:drop &mdash;force
$ php app/console doctrine:database:create</p>

<pre><code>[Doctrine\DBAL\Exception\ConnectionException]                                     
An exception occured in driver: SQLSTATE[42000] [1049] Unknown database 'mydatabase'
</code></pre>

<p>```</p>

<p>Well, it happens and I will tell you why.</p>

<h2>Command as a Service</h2>

<p>Since Symfony version 2.4 you can define your controllers and commands as
services. This is so useful as long as you need to treat your classes as much
decoupled as possible. You can check some information about how to define them
as services in
<a href="http://symfony.com/doc/current/cookbook/console/commands_as_services.html">Symfony Documentation</a>.</p>

<p>Then, let&rsquo;s figure out that our command is intended to check an entity from your
database. Of course, your command should be as empty as possible, placing all
your business logic inside your service layer (this is not the only strategy, of
course, but there is no strategy where you lace your logic inside your command).</p>

<p>Then, using commands as services, you will have this</p>

<ul>
<li>ObjectManager as a service (or Repository)</li>
<li>Your service, intended to do whatever you need to do, for example, check that
your entities are all enabled. Your ObjectManager or Repository will be injected
here</li>
<li>Your command, intended to work as the simple layer between your cli interface
and your service layer. Your service will be injected here.</li>
</ul>


<p>Given this schema, when we require this command through the DI Container, of
course a new Service instance will be created in order to inject it through the
command constructor, and the object will have to be created as well to be
injected inside the service.</p>

<p>It means create a new connection to the database. Fair enough till now :)</p>

<h2>Commands list</h2>

<p>Let me show you some lines of code. This method is placed in a class called
<code>Application</code> inside the bundle <code>FrameworkBundle</code>. This class is intended to add
the possibility of adding Commands as services in the main Application class of
Command Component.</p>

<p><a href="https://github.com/symfony/symfony/blob/2.7/src/Symfony/Bundle/FrameworkBundle/Console/Application.php">Symfony\Bundle\FrameworkBundle\Console\Application</a></p>

<p>``` php
protected function registerCommands()
{</p>

<pre><code>$container = $this-&gt;kernel-&gt;getContainer();
foreach ($this-&gt;kernel-&gt;getBundles() as $bundle) {
    if ($bundle instanceof Bundle) {
        $bundle-&gt;registerCommands($this);
    }
}
if ($container-&gt;hasParameter('console.command.ids')) {
    foreach ($container-&gt;getParameter('console.command.ids') as $id) {
        $this-&gt;add($container-&gt;get($id));
    }
}
</code></pre>

<p>}
```</p>

<p>Oh, wait&hellip; what?</p>

<p>Register a command means instantiate it! So if we have a command with a service
injected which has an object manager injected&hellip; then we have a problem. If we
don&rsquo;t have the database created we will not be able to create it using the
Doctrine command.</p>

<p><em>~ironic~ Perfect scenario for deployment ~/ironic~</em></p>

<h2>Using Lazy services</h2>

<p>Of course we should find a solution for this scenario, in order to be able to
call this command when is needed.</p>

<p>When we define as lazy a service, this is not instanced when is injected, but
only when is accessed. You can find some information about lazy services in
<a href="http://symfony.com/doc/current/components/dependency_injection/lazy_services.html">Symfony Documentation</a>.</p>

<p>The point here is to define our service intended to work with the model as lazy.
The result will be that when we instance the Command, then a proxy object is
created and injected with all the service information.</p>

<p>Because our command will not be used as long as we don&rsquo;t need it, then the
service will not be instanced and the ObjectManager not created. We will be able
to list all the commands, and finally, call
<code>php app/console doctrine:database:create</code> properly.</p>

<h2>Implementation</h2>

<p>Some tips here&hellip;</p>

<ul>
<li>Why instancing all services when we just need them to be listed? Is it really
necessary? Doing than we are forcing some service to be defined as lazy just
because of it, and this is not and will never be a good practice.</li>
<li>If the command needs to be instanced to be listed, and assuming that this
information <del>should</del> could be cached, then, is it necessary to call the
constructor? We could get the class, build the object using <code>\ReflectionClass</code>
and request all the needed information.</li>
</ul>


<p>I invoke the community for some feedback on that. If this is really a need for
some people, we should do some push (and organize us for an implementation,
maybe) to change this implementation for next Symfony 3 version.</p>

<p>Feedback, feedback :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Bye Bye Symfony]]></title>
    <link href="http://mmoreram.com/blog/2014/09/01/bye-bye-symfony/"/>
    <updated>2014-09-01T00:00:00+02:00</updated>
    <id>http://mmoreram.com/blog/2014/09/01/bye-bye-symfony</id>
    <content type="html"><![CDATA[<p>Don&rsquo;t be afraid. You know what I think about the Symfony components and how I
love them. Until now any circumstance has changed my mind about using them in my
projects, and over the time, after discover every hidden single piece of code, I
have turned more amazed of their power.</p>

<p>The reason of this post is just to tell you, with a simple example, how to say
<em>Bye Bye, Symfony!</em> and say <em>Hi PHP!</em>. This really means uncouple from Symfony
Components and still use them as the default implementation, while we can
securely remove, from the composer <em>require</em> block, our Symfony dependencies.</p>

<p>One of the poor things I have heard these last months has been the word <em>you must</em>
or <em>you should</em> event without knowing exactly what is the real direction of my
project, so every word in this post will be just an idea you could have in mind
when you design your own architecture, thinking about your real needs, far from
the things you should or you must do.</p>

<p>To explain that, how we can say goodbye to Symfony, we will start with a simple
example. A simple class we could find in every project. Our class will have no
sense but will be useful in our specific example, helping us to understand what
is all this about.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#121;&#x75;&#x68;&#x75;&#x40;&#x6d;&#109;&#x6f;&#x72;&#x65;&#114;&#97;&#x6d;&#x2e;&#99;&#111;&#x6d;">&#121;&#117;&#104;&#117;&#x40;&#x6d;&#x6d;&#111;&#114;&#101;&#x72;&#97;&#x6d;&#46;&#99;&#x6f;&#x6d;</a>
 </em>/</p>

<p>namespace Package\Generator;</p>

<p>use Symfony\Component\Routing\Generator\UrlGeneratorInterface;</p>

<p>/<em>*
 * Class UrlPrinter
 </em>/
class UrlPrinter
{</p>

<pre><code>/**
 * @var UrlGeneratorInterface
 *
 * Url generator
 */
protected $urlGenerator;

/**
 * Construct method
 *
 * @param UrlGeneratorInterface $urlGenerator Url generator
 */
public function __construct(UrlGeneratorInterface $urlGenerator)
{
    $this-&gt;urlGenerator = $urlGenerator;
}

/**
 * Generates Homepage route and print complete path
 *
 * @return string Route path
 */
public function printHomePageRoute()
{
    return $this
        -&gt;urlGenerator
        -&gt;generate('homepage');
}
</code></pre>

<p>}
```</p>

<p>As we can see, use this class means use <code>UrlGeneratorInterface</code>. This class is
part of the Symfony Routing Component, so is a really bad idea if you really
want to make your project multi-environment</p>

<p>Is that good? Well, it depends on your both product requirements and technical
requirements. If you want to use always the Symfony router component, this piece
of code is good enough. Otherwise, If you want to use another router, you have a
problem.</p>

<p>Say your project must work with and without Symfony. Our class should not depend
on this interface. One of the strategies to uncouple external implementations is
using ports and adapters.</p>

<p>I will explain how it works and how we can implement it.</p>

<h2>Real life example</h2>

<p>Let&rsquo;s imagine we want to sell an USB device. We have decided in our product
definition that this device will connect to external devices using USB Standard
A (the big one). One of the possible approaches would be to design our device
with the external connector coupled. This means selling it with the USB wire
(like an USB camera, for example).</p>

<p>But why coupling our device with an specific output? Do you know what it really
means?</p>

<ul>
<li>If the wire breaks, we must change all the device.</li>
<li>You can connect with devices that accept only USB-A</li>
<li>Wire improvements means new device versions.</li>
</ul>


<p>What would be an alternative decision? Well, why don&rsquo;t we focus our efforts in
the camera and we just let other companies to help us with the wire? This means
more flexibility for the final user and capability of removing and changing the
cable when is broken. And&hellip; they could connect their camera to many different
formats, even for the most adventurous, their own formats.</p>

<p>So, in fact, our device should have one female USB port with an specification
of how connect it with another device. The wire would be just an adapter of our
device so many of them could be plugged-in.</p>

<p>We have talked about devices, ports, adapters, specifications, but&hellip; how can
this help me with my project? Is that hard?</p>

<p>The answer is No.</p>

<h2>Solution</h2>

<p>Our goal is to create an specification for URL generators and force each adapter
to implement it in their own way. As we know, the OOP languages resolve the
specification with the interfaces.</p>

<p>Let&rsquo;s create our specification.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#121;&#117;&#104;&#117;&#64;&#x6d;&#x6d;&#111;&#x72;&#x65;&#x72;&#97;&#109;&#46;&#99;&#x6f;&#x6d;">&#x79;&#x75;&#104;&#117;&#64;&#x6d;&#x6d;&#x6f;&#114;&#101;&#x72;&#97;&#109;&#46;&#99;&#111;&#x6d;</a>
 </em>/</p>

<p>namespace Package\Specification;</p>

<p>/<em>*
 * Interface PackageUrlGeneratorInterface
 </em>/
interface PackageUrlGeneratorInterface
{</p>

<pre><code>/**
 * Generates a route given its name.
 *
 * @return string Route path
 */
public function generateUrl($routeName);
</code></pre>

<p>}
<code>``
We are just specifying. We want that, whatever is the implementation, each
adapter must fulfill this rule: Has a method called</code>generateRoute` that, given
the route name, will return its complete path.</p>

<p>Let&rsquo;s adapt our UrlPrinter to work with specification instead of implementation.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#58;&#121;&#x75;&#x68;&#117;&#x40;&#109;&#x6d;&#x6f;&#x72;&#101;&#x72;&#x61;&#x6d;&#46;&#x63;&#x6f;&#109;">&#121;&#x75;&#104;&#x75;&#64;&#109;&#109;&#111;&#x72;&#101;&#114;&#97;&#x6d;&#46;&#99;&#111;&#x6d;</a>
 </em>/</p>

<p>namespace Package\Generator;</p>

<p>use Package\Specification\PackageUrlGeneratorInterface;</p>

<p>/<em>*
 * Class UrlPrinter
 </em>/
class UrlPrinter
{</p>

<pre><code>/**
 * @var PackageUrlGeneratorInterface
 *
 * Url generator
 */
protected $urlGenerator;

/**
 * Construct method
 *
 * @param UrlGeneratorInterface $urlGenerator Url generator
 */
public function __construct(PackageUrlGeneratorInterface $urlGenerator)
{
    $this-&gt;urlGenerator = $urlGenerator;
}

/**
 * Generates Homepage route and print complete path
 *
 * @return string Route path
 */
public function printHomePageRoute()
{
    return $this
        -&gt;urlGenerator
        -&gt;generateUrl('homepage');
}
</code></pre>

<p>}
```</p>

<p>Now, our UrlPrinter does not depends on any external library. Goal reached!</p>

<p>But, now what? I mean, we should implement our adapter, am I right? What is a
camera with a great specification and without wire plugged in? (A wireless
camera, welcome to the twenty century ^^. Just joking)</p>

<p>Our UrlPrinter needs a <em>PackageUrlGeneratorInterface</em> implementation to be
built, so we have to implement an adapter. And because we still want to work with
Symfony Routing Component as my first option, we will create the Symfony Adapter
for my specification.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x79;&#117;&#x68;&#117;&#x40;&#x6d;&#109;&#111;&#114;&#x65;&#x72;&#97;&#x6d;&#x2e;&#x63;&#111;&#x6d;">&#x79;&#117;&#104;&#x75;&#64;&#109;&#x6d;&#x6f;&#x72;&#101;&#x72;&#97;&#x6d;&#x2e;&#x63;&#111;&#109;</a>
 </em>/</p>

<p>namespace Package\Adapter;</p>

<p>use Package\Specification\PackageUrlGeneratorInterface;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;</p>

<p>/<em>*
 * Class SymfonyUrlGeneratorAdapter
 </em>/
class SymfonyUrlGeneratorAdapter implements PackageUrlGeneratorInterface
{</p>

<pre><code>/**
 * @var UrlGeneratorInterface
 *
 * Url generator
 */
protected $urlGenerator;

/**
 * Construct method
 *
 * @param UrlGeneratorInterface $urlGenerator Url generator
 */
public function __construct(UrlGeneratorInterface $urlGenerator)
{
    $this-&gt;urlGenerator = $urlGenerator;
}

/**
 * Generates a route given its name
 *
 * @return string Route path
 */
public function generateUrl($routeName)
{
    $this
        -&gt;urlGenerator
        -&gt;generate($routeName);
}
</code></pre>

<p>}
```</p>

<p>This an adapter, my friends. Each adapter has one mission, and is just transform
the way we understand the method <code>generateUrl</code> must work (specification) to the
way each external project understands it (implementation). In this case, very
easy, our <code>generateUrl</code> is the same as Symfony Router Component&rsquo;s <code>generate</code>.</p>

<p>Symfony Component is now required by this adapter, but because we are not
required to use this adapter (Maybe we can use a dummy one for our tests, or a
mocked one), Symfony Component is not required by our package anymore, just
suggested.</p>

<p>Let&rsquo;s see another Adapter implementation, requiring another external library.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#x6d;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#121;&#117;&#104;&#x75;&#x40;&#x6d;&#109;&#111;&#x72;&#101;&#114;&#97;&#109;&#x2e;&#x63;&#111;&#x6d;">&#121;&#117;&#x68;&#x75;&#x40;&#x6d;&#x6d;&#x6f;&#114;&#x65;&#x72;&#97;&#x6d;&#46;&#99;&#x6f;&#109;</a>
 </em>/</p>

<p>namespace Package\Adapter;</p>

<p>use Package\Specification\PackageUrlGeneratorInterface;
use AnotherProject\UrlGeneratorInterface;</p>

<p>/<em>*
 * Class SymfonyUrlGeneratorAdapter
 </em>/
class SymfonyUrlGeneratorAdapter implements PackageUrlGeneratorInterface
{</p>

<pre><code>/**
 * @var UrlGeneratorInterface
 *
 * Url generator
 */
protected $urlGenerator;

/**
 * Construct method
 *
 * @param UrlGeneratorInterface $urlGenerator Url generator
 */
public function __construct(UrlGeneratorInterface $urlGenerator)
{
    $this-&gt;urlGenerator = $urlGenerator;
}

/**
 * Generates a route given its name
 *
 * @return string Route path
 */
public function generateUrl($routeName)
{
    $routeName = '_' . $routeName;

    $this
        -&gt;urlGenerator
        -&gt;anotherGenerateMethod($routeName);
}
</code></pre>

<p>}
```</p>

<p>Both adapters would be placed in the <code>Adapter/</code> folder, and the final user
should be able to switch them and even implement new ones.</p>

<h2>From require to suggest</h2>

<p>With our changes, we can remove &ldquo;symfony/routing&rdquo; from the require block and add
it into the suggest block in <code>composer.json</code> file.</p>

<p>``` yml
&ldquo;require&rdquo;: {</p>

<pre><code>"php": "&gt;=5.4",
...
</code></pre>

<p>},
&ldquo;suggest&rdquo;: {</p>

<pre><code>"symfony/routing": "Required if using Routing adapter",
"mmoreram/another-project": Required if using AnotherProject Routing adapter"
</code></pre>

<p>},
```</p>

<p>We will only require the packages needed by the adapter we are using.</p>

<h2>What we win</h2>

<p>Much. We win maximum implementation flexibility and minimum coupling. Would be
wise to say that a PHP project should tend to this thought, but once again, it
depends on many factors.</p>

<h2>What we lose</h2>

<p>It Depends. If you want your project to be understandable by a lot of developing
knowledge levels, this architecture goes away from the comprehensibility of a
simple code. You also can lose by having lot of files, so you should respect
some kind of best practices code, to make people working on your project
comfortable dealing with it.</p>

<h2>Best practices</h2>

<p>I should talk about <em>Marc practices</em> instead of <em>Best practices</em>. I am used to
adding my adapters always in the folder <code>/Adapter/{PortName}/</code>, being <em>PortName</em>
the name of the port we are dealing with in camel case format. In this case, we
should add both adapters in <code>/Adapter/UrlGenerator/</code>.</p>

<p>Given this format we can determine what adapters we can use in our project in a
very agile way.</p>

<h2>Reference projects</h2>

<p>First project that comes in my mind when I think about Ports/Adapters is
<a href="https://github.com/KnpLabs/Gaufrette/tree/master/src/Gaufrette">Gaufrette</a>, a
filesystem abstraction layer with a lot of adapters implemented.</p>

<p>In <a href="https://github.com/elcodi/elcodi">Elcodi</a> we are actually using this
library and its really awesome how easy is using it.</p>

<p>We have also implemented internally some features using this architecture, for
example, the <a href="https://github.com/elcodi/elcodi/tree/master/src/Elcodi/Component/Geo/Adapter/Populator">Geo Schema Populator</a>,
a new feature under development that will allow you to populate all Geo schema
using some adapters. Right now only GeoData adapter is implemented.</p>

<p>Another example, the
<a href="https://github.com/elcodi/elcodi/tree/master/src/Elcodi/Component/Currency/Adapter/CurrencyExchangeRatesProvider">Currency Exchange Rates Populator</a>
with OpenExchangeRates implementation already done.</p>

<h2>Final thoughts</h2>

<p>Using ports and adapters is really a great tool for those who want to uncouple
from implementations and a great pattern if you develop open source. Open source
should satisfy as people as possible, so remember, specify and then implement.</p>

<p>Try it and then tell us your experience :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elcodi, una nueva aventura en Symfony2]]></title>
    <link href="http://mmoreram.com/blog/2014/04/17/elcodi/"/>
    <updated>2014-04-17T12:46:00+02:00</updated>
    <id>http://mmoreram.com/blog/2014/04/17/elcodi</id>
    <content type="html"><![CDATA[<p>Ciertos cambios están por llegar. Y parece ser que son cambios buenos. Llevo
unas cuantas semanas sin escribir en el blog, y la verdad es que me sabe mal.
Me gusta contar cosas que me van sucediendo en la empresa. Problemas que nos
vamos encontrando y soluciones que se me van ocurriendo. El problema es que
llevo unos meses muy centrado en el proyecto que justo hoy lanzamos al mundo.
Es un proyecto inicialmente de desarrolladores para desarrolladores, centrado en
cubrir necesidades reales de los developers destinados a diseñar y
programar ecommerces.</p>

<p>Es cierto que tenemos muchísimas plataformas y opciones para desarrollar
ecommerces alrededor del mundo. Podría enumerar unos cuantos, y probablemente
todos tengan unas métricas y unos KPIs magníficos.</p>

<p>Los problemas de estas plataformas es que son completamente B2B, por lo que tienen sentido cuando
el usuario final simplemente debe tener una buena interfaz de administración,
de instalación y de configuración; y que cuando los departamentos técnicos quieren
desarrollar, tanto horizontalmente ( nuevas funcionalidades de
aquello que ya se está utilizando, o simplemente customizar ) como verticalmente
( nuevas funcionalidades ), estas plataformas B2B se quedan
cortas, por lo que la empresa tiene que desembolsar una cantidad enorme de
dinero en un refáctoring, o simplemente, se debe empezar a todar el código
existente, ensuciándolo y haciendo peligrar su integridad.</p>

<p>Estas plataformas no suelen estar testeadas, por lo que cada línea que se añade
es una línea potencialmente dañina para todo el sistema, con lo que cada
desarrollo sobre estas plataformas suelen derivar en problemas colaterales
en la propia experiencia de usuario.</p>

<p>Desde mi punto de vista, en los tiempos que corren, esto es inaceptable.</p>

<p>Nosotros proponemos una plataforma pensada para los desarrolladores, pensada
y profundamente reflexionada. Esto no implica que el código deba estar bien
en una primera instancia, simplemente nuestra declaración de intenciones es
llevar el proyecto a un punto donde las empresas puedan confiar en el proyecto
para construir el suyo propio.</p>

<p>Os presentamos <a href="http://elcodi.io">Elcodi</a>.</p>

<p>En un planteamiento dividido en fases, justo estamos naciendo. Tenemos muy claro
cual es nuestro roadmap, por lo que en los próximos meses se desarrollaran las
principales features a nivel de core, así como la robustez necesaria como para
poder lidiar con colaboradores externos, que les guste el proyecto en su estado
inicial y que quieran acomparnos en este viaje, destinado a mejorar el estilo de
vida de los developers.</p>

<p>La plataforma está basada en Symfony2, y siguiendo la filosofía definida por el
propio framework, hemos enfocado la mayor parte de la arquitectura utilizando
una fuerte capa de eventos, desacoplando la mayoría de comportamientos y
componentes completamente.</p>

<p>Si eres programador Symfony, te propongo que almenos le eches un vistazo.
Verás errores, mil cosas a desarrollar y mil cosas a mejorar, pero como todo
proyecto, nuestra mayor ambición es la propia construcción del mismo, por lo que
es cuestión de meses, ganas y desarrollo.</p>

<p>Otro de nuestros objetivos es llegar a construir una buena documentación.
Tenemos esencialmente tres líneas de documentación en mente. Por un lado</p>

<p>queremos transmitir a los demás nuestra filosofía. La dirección que, sin duda
alguna, tomará el proyecto, independientemente de la implementación que este
adquiera en un momento dado. Es importante definir esto inicialmente porque al
final nos vincula muchísimo al target al que vamos destinados.</p>

<p>La documentación es algo lento, también sujeta a colaboraciones, y en principio
estará inicialmente solo en inglés.</p>

<p>Finalmente decir que elcodi.com es una empresa en plena expansión. Tenemos
buenas previsiones de crecimiento por lo que tenemos una garantía que lo que hoy
con tanta ilusión estamos empezando, no dejará de crecer.</p>

<p>Queremos que sea útil, queremos que nuestra propuesta esté a juicio de todo el
mundo y que saque vuestras críticas mas constructivas, solo así podremos
realmente hacer un proyecto interesante para todos.</p>
]]></content>
  </entry>
  
</feed>
