<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: symfony | Because yes]]></title>
  <link href="http://mmoreram.github.io/blog/categories/symfony/atom.xml" rel="self"/>
  <link href="http://mmoreram.github.io/"/>
  <updated>2015-09-07T21:57:53+02:00</updated>
  <id>http://mmoreram.github.io/</id>
  <author>
    <name><![CDATA[Marc Morera]]></name>
    <email><![CDATA[yuhu@mmoreram.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Symfony Barcelona Event, September 2015]]></title>
    <link href="http://mmoreram.github.io/blog/2015/09/07/symfony-barcelona-event-september-2015/"/>
    <updated>2015-09-07T21:38:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2015/09/07/symfony-barcelona-event-september-2015</id>
    <content type="html"><![CDATA[<p>It is a pleasure for me to announce that next September 22nd we will have a
great event in Barcelona. I&rsquo;ve talked many times about this local organization,
but this time is pretty different. I&rsquo;ll explain you.</p>

<p>This year Barcelona hosts the
<a href="https://events.drupal.org/barcelona2015">DrupalCon Europe 2015</a>, and this is
super exciting. Many people from around the world will visit our great and
amazing streets and will attend to a great and big event, related with Drupal,
Symfony and other interesting topics, always, related to the Drupal world.</p>

<p>This is very interesting from the point of view of Symfony, because as you may
know, new version of drupal, Drupal8, is build using some Symfony components.
This is one of the examples I refer when I talk about sharing technologies
between PHP projects and when I talk about open source, community and other
related topics. We&rsquo;ve seen these synergies between other PHP projects and
Symfony as well with Laravel, eZ Publish, Magento and Joomla (and many more,
indeed)</p>

<p>So, this is a call to all the community coming to Barcelona next September 21st.
We will host Fabien Potencier, the creator of Symfony, and Lukas Kahwe Smith, an
amazing and super active PHP developer, member, for example, of the PHP-FIG
group.</p>

<p><a href="http://symfony-barcelona.es">http://symfony-barcelona.es</a></p>

<p>Isn&rsquo;t it interesting? Indeed, but this is not all!</p>

<p>We are planning to overcome our last assistance record, which is 140 attendees.
This time, we want to fill an auditorium of 600 seats and show you what really
is Barcelona, and how amazing can be :)</p>

<p>Our sponsors are ready<br/>
The community is ready<br/>
The organization is ready<br/>
Only one thing is missing here&hellip;</p>

<p><strong>You!</strong></p>

<p><a href="http://symfony-barcelona.es#register">Join us now for free!</a> and please share
this post to allow everyone to know about it!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EventListeners as collectors in Symfony]]></title>
    <link href="http://mmoreram.github.io/blog/2015/08/28/eventlisteners-as-collectors-in-symfony/"/>
    <updated>2015-08-28T12:04:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2015/08/28/eventlisteners-as-collectors-in-symfony</id>
    <content type="html"><![CDATA[<p>Some of my concerns during the last couple of years have been how to collect
data from all installed bundles using available tools in Symfony packages.
I say concerns because I don&rsquo;t really know if is there a tool for that.</p>

<p>Some people have told me that the
<a href="http://symfony.com/doc/current/components/event_dispatcher/introduction.html">EventDispatcher component</a>
can do this work greatly, but then I have the same question once and again&hellip; is
this component designed for such?</p>

<p>Let&rsquo;s review some tiny concepts here.</p>

<h2>Event immutability</h2>

<p>Try to think what really is an event. Something that happens. For example, I
wake up. Once I wake up, an event is dispatched called <code>mmoreram.wake_up</code>. This
event, of course, is immutable. Nothing can change the fact that I woke up, so
the event should be treated as an immutable object, with only reading actions.</p>

<p>One single property of the event is injected once is created. Did I wake up
rested enough for a new crazy day with all cool guys from my office?</p>

<p>``` php
namespace Mmoreram;</p>

<p>use Symfony\Component\EventDispatcher\Event;</p>

<p>/<em>*
 * Marc woke up event
 </em>/
class MmoreramWakeUpEvent extends Event
{</p>

<pre><code>/**
 * @var boolean
 *
 * Marc woke up rested
 */
private $rested;

/**
 * Construct method
 *
 * @var boolean $rested Marc woke up rested
 */
public function __construct($rested)
{
    $this-&gt;rested = $rested;
}

/**
 * Get if Marc is rested enough
 *
 * @return boolean Marc is rested enough
 */
public function isRested()
{
    return $this-&gt;rested;
}
</code></pre>

<p>}
```</p>

<p>Of course, no one should be able to change the value of rested, because no one
has the <strong>power</strong> to change the fact I woke up tired this night.</p>

<p>The main intention of an event is notify the world that something just happened,
so any extra implementation changing this paradigm should be avoided in order to
not corrupt the real meaning of the component.</p>

<p>Said that, and before continuing with the post&hellip; a question related to this
topic. Just make sure that you can take some time to think about that.</p>

<p>If we talk about decoupling between components&hellip; is the concept of <code>priority</code>
helpful? If any actor must know the priorities of all listeners in order to know
its own&hellip; then can we consider that all event listeners are really decoupled
between them? And how bad is that?</p>

<h2>Collector</h2>

<p>Let&rsquo;s figure out that the system need to collect some feelings when I wake up.
Let&rsquo;s figure out as well that we don&rsquo;t really care about how these feelings are
sorted, so the problem of priority is not a problem anymore: we can ignore it
completely.</p>

<p>We can change our event with this new implementation.</p>

<p>``` php
namespace Mmoreram;</p>

<p>use Symfony\Component\EventDispatcher\Event;
use Mmoreram\Feeling;</p>

<p>/<em>*
 * Marc woke up event
 </em>/
class MmoreramWakeUpEvent extends Event
{</p>

<pre><code>/**
 * @var boolean
 *
 * Marc woke up rested
 */
private $rested;

/**
 * @var Feeling[]
 *
 * Array of feelings
 */
private $feelings;

/**
 * Construct method
 *
 * @var boolean $rested Marc woke up rested
 */
public function __construct($rested)
{
    $this-&gt;rested = $rested;
    $this-&gt;feelings = [];
}

/**
 * Add new feeling
 *
 * @param Feeling $feeling New feeling to be added
 *
 * @return $this Self object
 */
public function addFeeling(Feeling $feeling)
{
    $this-&gt;feelings[] = $feeling;

    return $this;
}

/**
 * Get if Marc is rested enough
 *
 * @return boolean Marc is rested enough
 */
public function isRested()
{
    return $this-&gt;rested;
}

/**
 * Get all feelings
 *
 * @return Feeling[] Set of feelings
 */
public function getFeelings()
{
    return $this-&gt;feelings;
}
</code></pre>

<p>}
```</p>

<p>Of course, in our domain we must dispatch this event one I really wake up (for
example a service called <code>MmoreramVitalActions</code></p>

<p>``` php
use Symfony\Component\EventDispatcher\EventDispatcher;
use Symfony\Component\EventDispatcher\Event;
use Mmoreram\MmoreramWakeUpEvent;</p>

<p>/<em>*
 * Marc vital actions
 </em>/
class MmoreramVitalActions
{</p>

<pre><code>/**
 * Marc wakes up
 *
 * @return Feeling[] Set of feelings resulting of the action of waking up
 */
public function wakeUp()
{
    $rested = $this-&gt;didMarcRestedProperly();
    $eventDispatcher = new EventDispatcher();
    $event = new MmoreramWakeUpEvent($rested);

    $dispatcher
        -&gt;dispatch(
            'mmoreram.wake_up',
            $event
        );

    return $event-&gt;getFeelings();
}

/**
 * Get if Marc rested properly
 *
 * @return boolean Marc rested properly
 */
private function didMarcRestedProperly();
</code></pre>

<p>}
```</p>

<p>As you can see, after dispatching the event you should be able to get all
collected feelings. This means that the one in charge to fulfill this
information related to my feelings should be any event listener interested in
adding it&rsquo;s own related feeling.</p>

<p>For example, an Event Listener will have the responsibility to add a feeling
related to the temperature of my room.</p>

<p>``` php
use Mmoreram\MmoreramWakeUpEvent;</p>

<p>/<em>*
 * Marc wake up event listener related to temperature.
 * This class is intended to add a feeling depending on local temperature
 </em>/
class TemperatureMmoreramWakeUpEventListener
{</p>

<pre><code>/**
 * Marc wakes up listener
 *
 * @param MmoreramWakeUpEvent $event Marc wake up event
 *
 * @return $this Self object
 */
public function addTemperatureFeeling(MmoreramWakeUpEvent $event)
{
    $feeling = $this-&gt;getTemperatureFeeling();
    $event-&gt;addFeeling($feeling);

    return $this;
}

/**
 * Get feeling related to the temperature
 *
 * @return Feeling Feeling related to temperature
 */
private function getTemperatureFeeling();
</code></pre>

<p>}
```</p>

<p>Of course, you must add this event listener using tags in the Dependency
Injection Symfony configuration.</p>

<p><a href="http://symfony.com/doc/current/reference/dic_tags.html">Using tags for our listeners definition</a></p>

<p>At this point, you can see that maybe this is useful. This is a very easy and
fast collector implementation, but not enough good. The event is not immutable
anymore and you can change if from any event dispatcher, very far from the real
intention of the component.</p>

<h2>Solution</h2>

<p>I am using this approach in order to be as much pragmatic as possible. Of course
this works properly by adding an extra definition and documentation layer, but
I wonder if other people is concerned about that in Symfony.</p>

<p>I don&rsquo;t really think that yet another component called Collector would be
necessary at all unless there is an abstraction between both components (they
share some common things related to the fact of broadcasting and subscribing).</p>

<p>Of course, again, simple theory and personal thoughts brought to the community.
I will continue using this approach even knowing that should be solved using
another one as long as people understand it and is easy to work with.</p>

<p>Feedback and people thoughts will be appreciated, as always :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Symfony in Barcelona]]></title>
    <link href="http://mmoreram.github.io/blog/2015/08/23/symfony-in-barcelona/"/>
    <updated>2015-08-23T17:22:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2015/08/23/symfony-in-barcelona</id>
    <content type="html"><![CDATA[<p>Barcelona, one of the best cities in the world.</p>

<p>For you, Symfony lover. Do you know where is Barcelona, right?
Well, this is a call for all Symfony lovers who want something special,
something really different. Amazing people, amazing food and tons and tons of
new experiences with one of the greatest Symfony Communities around the world.</p>

<iframe width="1280" height="720" src="http://www.youtube.com/embed/6DxX1DYHOlk?feature=player_detailpage&VQ=HD720" frameborder="0" allowfullscreen></iframe>


<p>A lot of companies are actually being built in this city, so we really want you
with us. No matter your Symfony expertise, no matter how good you really are&hellip;
in Barcelona only matters one simple thing&hellip; How good you want to be. If you
want to be one of the bests, then Barcelona can be your new home :)</p>

<p>If you want to know more about it, just send an email to Symfony Barcelona User
Group and you will be properly helped to move here with us. The group email is
<a href="&#x6d;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x73;&#x79;&#x6d;&#x66;&#111;&#110;&#121;&#98;&#x61;&#x72;&#x63;&#x65;&#x6c;&#x6f;&#x6e;&#97;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;">&#115;&#x79;&#109;&#x66;&#x6f;&#110;&#121;&#98;&#x61;&#114;&#x63;&#x65;&#108;&#111;&#x6e;&#x61;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;</a></p>

<p>You want to join us, but you don&rsquo;t know it yet :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elcodi wants you]]></title>
    <link href="http://mmoreram.github.io/blog/2014/07/21/elcodi-wants-you/"/>
    <updated>2014-07-21T21:28:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/07/21/elcodi-wants-you</id>
    <content type="html"><![CDATA[<p>Right. Elcodi wants you.</p>

<p><a href="http://elcodi.io">Elcodi Project</a></p>

<p>And Elcodi wants you because you are ambitious, a fighter, a ninja developer
eager to learn and to teach.</p>

<p>Elcodi wants you because you are a follower of good practices and have a sound
software craftsmanship mindset, because you are a perfectionist, because your
inspiring work is a way of life.</p>

<p>Elcodi wants you because you firmly believe that an open-source environment is a
trigger that can detonate personal and professional achievements.</p>

<p>We believe we are doing a good job. We are not alone in believing it, many
others do. This is why we have decided take it to the next level and start to
evolve, growing the team and our vision.</p>

<p>We really aim to make things the right way by unfolding the power of
collaborative software development and this is why we need your voice, your
ideas, your enthusiasm and, of course, we need your hands. Skillful, experienced
and visionary artisan hands.</p>

<p>If you share our vision and want to collaborate with a truly inspiring project,
contact me at <code>yuhu@mmoreram.com</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ControllerExtraBundle, some useful Controller annotations]]></title>
    <link href="http://mmoreram.github.io/blog/2014/06/30/controller-extra-bundle/"/>
    <updated>2014-06-30T17:03:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/06/30/controller-extra-bundle</id>
    <content type="html"><![CDATA[<p>Few days ago, at the bimonthly meeting of Symfony2 Barcelona, attendees
began to discuss the annotations. Obviously, given that it is a
practice that goes against many many philosophies or architectural strategies ,
many people were against them, and some people where I include myself, were in
favor.</p>

<p>Being in favor of annotations does not mean wanting to use everywhere
but take them into account when the occasion required it is.</p>

<p>We could divide Symfony2 project into two blocks in this case. the
first is the model, a set of elements that implement our domain.
Doctrine has some annotations to define how this model maps to the
database, and I admit that at the first, when you are in the lower part
and elemental learning curve, are very positive elements for all developers.</p>

<p>However, at the time that you must have actual control of your domain, and
the time domain may be used in more than one project and more than
a framework, we have a problem. So, and I will not go into details,
I conclude that annotations never should be used in the domain model.</p>

<p>On the other hand, we have the application, the entry point. The controllers.</p>

<p>Let me ask you a question.</p>

<p>Do you think your application will change its framework someday? And given that
the answer is affirmative&hellip; Do you think you will maintain your controllers?</p>

<p>Both questions can be answered affirmatively, but is a very very rarely
situation where, surely, most of you will never have to manage. So I think that
we should thread Controllers in a very different way than Model.</p>

<p>IMHO, I am used to using annotations, because simplifies a lot some repetitive
processes, and gives me a very visual definition of what my action is responding
against, and what configuration are being applied.</p>

<p>Maybe is not the best of the options in some cases, but if the annotations is
well documented and defined, maybe could be useful in lot of cases.</p>

<p>In Symfony Controllers we have those annotations (Surely there are more, but I
consider that those are the most useful of them)</p>

<ul>
<li>ParamConverter &ndash; Good annotation. The code is a little bit messy but I am very
thankful. At the point I needed to define the namespace of the entity through a
container parameter, this annotations became useless.</li>
<li>Method, Router y Template &ndash; Very useful for non-customizable projects. Worth
considering in our projects if we really do not need any kind of customization,
like custom routes.</li>
<li>Secure &ndash; Static. Very useful if you accept your controllers will never change
its secure definition.</li>
</ul>


<p>Given my little devotion for these controller annotations, some months ago I
decided to detect some needs I had in some personal projects, needs to repeat
some code once and again, code that had nothing to do with my business. I tried
to implement my annotations as flexible as possible.</p>

<p>For that I created <a href="https://github.com/mmoreram/ControllerExtraBundle">ControllerExtraBundle</a>.
This bundle, in addition to provide a set of Symfony2 annotations for
controllers, provides you a platform and a documentation to implement yourself
your own needs.</p>

<p>Actually this bundle is stable at version <code>v.1.1.2</code> and have this annotations</p>

<h2>@Paginator</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#paginator">@Paginator Documentation</a></p>

<p>Allows you to inject a Doctrine Paginator given a route and a configuration. Is
very flexible but has to evolve even more.</p>

<p><code>php
/**
 * Simple controller method
 *
 * This Controller matches pattern /paginate/nb/{limit}/{page}
 *
 * Where:
 *
 * * limit = 10
 * * page = 1
 *
 * @PaginatorAnnotation(
 *      class = (
 *          factoryClass = "Mmoreram\ControllerExtraBundle\Factory\EntityFactory",
 *          factoryMethod = "create",
 *          factoryStatic = true
 *      ),
 *      page = "~page~",
 *      limit = "~limit~",
 *      orderBy = {
 *          { "x", "createdAt", "ASC" },
 *          { "x", "updatedAt", "DESC" },
 *          { "x", "id", "0", {
 *              "1" = "ASC",
 *              "2" = "DESC",
 *          }}
 *      },
 *      wheres = {
 *          { "x", "enabled" , "=", true }
 *      },
 *      leftJoins = {
 *          { "x", "relation", "r" },
 *          { "x", "relation2", "r2" },
 *          { "x", "relation5", "r5", true },
 *      },
 *      innerJoins = {
 *          { "x", "relation3", "r3" },
 *          { "x", "relation4", "r4", true },
 *      },
 *      notNulls = {
 *          {"x", "address1"},
 *          {"x", "address2"},
 *      }
 * )
 */
public function indexAction(Paginator $paginator)
{
}
</code></p>

<h2>@Entity</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#entity">@Entity Documentation</a></p>

<p>Generates a new entity instance, given an entity definition. This definition can
be given a namespace, a container parameter, a doctrine shortcut or a factory
definition.</p>

<p>``` php
&lt;?php</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Entity;
use Mmoreram\ControllerExtraBundle\Entity\User;</p>

<p>/<em>*
 * Simple controller method
 *
 * This Controller matches pattern /user/edit/{id}/{username}
 *
 * @Entity(
 *      class = {
 *          &ldquo;factory&rdquo; = &ldquo;my.factory.service&rdquo;,
 *          &ldquo;method&rdquo;  = &ldquo;generate&rdquo;,
 *          &ldquo;static&rdquo;  = false,
 *      },
 *      name  = &ldquo;user&rdquo;
 * )
 </em>/
public function indexAction(User $user)
{</p>

<pre><code>// $user is an empty instance
</code></pre>

<p>}
```</p>

<p>You can also, and since some days ago, not only inject an empty entity instance
but retrieve an existing mapped instance like ParamConverter does, but in a very
easy way.</p>

<p>``` php
&lt;?php</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Entity;
use Mmoreram\ControllerExtraBundle\Entity\User;</p>

<p>/<em>*
 * Simple controller method
 *
 * This Controller matches pattern /user/edit/{id}/{username}
 *
 * @Entity(
 *      class = &ldquo;MmoreramCustomBundle:User&rdquo;,
 *      name  = &ldquo;user&rdquo;,
 *      mapping = {
 *          &ldquo;id&rdquo;: &ldquo;~id~&rdquo;,
 *          &ldquo;username&rdquo;: &ldquo;~username~&rdquo;
 *      }
 * )
 </em>/
public function indexAction(User $user)
{</p>

<pre><code>// $user is a mapped entity
</code></pre>

<p>}
```</p>

<h2>@Form</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#form">@Form Documentation</a></p>

<p>Generates a simple FormType, FormInterface of FormView instance, given a form
definition. You can also configure it to create given a mapped or a new entity
instance and you can also handleRequest it and validate.</p>

<p>To create it given a mapped or a new entity instance, you can combine it using
both @ParamConverter or @Entity annotations.</p>

<p>``` php
&lt;?php</p>

<p>use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\Form\Form;</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Form as AnnotationForm;
use Mmoreram\ControllerExtraBundle\Entity\User;</p>

<p>/<em>*
 * Simple controller method
 *
 * @Route(
 *      path = &ldquo;/user/{id}&rdquo;,
 *      name = &ldquo;view_user&rdquo;
 * )
 * @Entity(
 *      class = &ldquo;MmoreramCustomBundle:User&rdquo;,
 *      name  = &ldquo;user&rdquo;,
 *      mapping = {
 *          &ldquo;id&rdquo;: &ldquo;~id~&rdquo;
 *      }
 * )
 * @AnnotationForm(
 *      class         = &ldquo;user_type&rdquo;,
 *      entity        = &ldquo;user&rdquo;
 *      handleRequest = true,
 *      name          = &ldquo;userForm&rdquo;,
 *      validate      = &ldquo;isValid&rdquo;,
 * )
 </em>/
public function indexAction(User $user, Form $userForm, $isValid)
{
}
```</p>

<h2>@Flush</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#flush">@Flush Documentation</a></p>

<p>Allows you to automate a flush every time a response is returned. There are
some real philosophies that say that a single flush should be executed always
at the end of the request.</p>

<p>``` php
&lt;?php</p>

<p>use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Flush;
use Mmoreram\ControllerExtraBundle\Entity\Address;
use Mmoreram\ControllerExtraBundle\Entity\User;</p>

<p>/<em>*
 * Simple controller method
 *
 * @ParamConverter(&ldquo;user&rdquo;, class=&ldquo;MmoreramCustomBundle:User&rdquo;)
 * @ParamConverter(&ldquo;address&rdquo;, class=&ldquo;MmoreramCustomBundle:Address&rdquo;)
 * @Flush(
 *      entity = {
 *          &ldquo;user&rdquo;,
 *          &ldquo;address&rdquo;
 *      }
 * )
 </em>/
public function indexAction(User $user, Address $address)
{
}
```</p>

<h2>@JsonResponse</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#jsonresponse">@JsonResponse Documentation</a></p>

<p>This annotation converts your controller return value in a single response,
using your data serialized with php <code>json_encode()</code>. This follows same way
@Template does.</p>

<p>IMHO, very useful.</p>

<p>``` php
&lt;?php</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\JsonResponse;</p>

<p>/<em>*
 * Simple controller method
 *
 * @JsonResponse
 </em>/
public function indexAction(User $user, Address $address)
{</p>

<pre><code>return array(
    'This is my response'
);
</code></pre>

<p>}
```</p>

<h2>@Log</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#log">@Log Documentation</a></p>

<p>Automatic log system for controller methods. You can define level of your log
and the moment you want to do it (before, after, both)</p>

<p>``` php
&lt;?php</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Flush;</p>

<p>/<em>*
 * Simple controller method
 *
 * @Log(
 *      value   = &ldquo;Executing index Action&rdquo;,
 *      level   = @Log::LVL_WARNING
 * )
 </em>/
public function indexAction()
{
}
```</p>
]]></content>
  </entry>
  
</feed>
