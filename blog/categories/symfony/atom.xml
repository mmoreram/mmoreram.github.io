<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Symfony | Because yes]]></title>
  <link href="http://mmoreram.github.io/blog/categories/symfony/atom.xml" rel="self"/>
  <link href="http://mmoreram.github.io/"/>
  <updated>2014-05-19T17:42:13+02:00</updated>
  <id>http://mmoreram.github.io/</id>
  <author>
    <name><![CDATA[Marc Morera]]></name>
    <email><![CDATA[yuhu@mmoreram.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elcodi, una nueva aventura en Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2014/04/17/elcodi/"/>
    <updated>2014-04-17T12:46:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/04/17/elcodi</id>
    <content type="html"><![CDATA[<p>Ciertos cambios están por llegar. Y parece ser que son cambios buenos. Llevo
unas cuantas semanas sin escribir en el blog, y la verdad es que me sabe mal.
Me gusta contar cosas que me van sucediendo en la empresa. Problemas que nos
vamos encontrando y soluciones que se me van ocurriendo. El problema es que
llevo unos meses muy centrado en el proyecto que justo hoy lanzamos al mundo.
Es un proyecto inicialmente de desarrolladores para desarrolladores, centrado en
cubrir necesidades reales de los developers destinados a diseñar y
programar ecommerces.</p>

<p>Es cierto que tenemos muchísimas plataformas y opciones para desarrollar
ecommerces alrededor del mundo. Podría enumerar unos cuantos, y probablemente
todos tengan unas métricas y unos KPIs magníficos.</p>

<p>Los problemas de estas plataformas es que son completamente B2B, por lo que tienen sentido cuando
el usuario final simplemente debe tener una buena interfaz de administración,
de instalación y de configuración; y que cuando los departamentos técnicos quieren
desarrollar, tanto horizontalmente ( nuevas funcionalidades de
aquello que ya se está utilizando, o simplemente customizar ) como verticalmente
( nuevas funcionalidades ), estas plataformas B2B se quedan
cortas, por lo que la empresa tiene que desembolsar una cantidad enorme de
dinero en un refáctoring, o simplemente, se debe empezar a todar el código
existente, ensuciándolo y haciendo peligrar su integridad.</p>

<p>Estas plataformas no suelen estar testeadas, por lo que cada línea que se añade
es una línea potencialmente dañina para todo el sistema, con lo que cada
desarrollo sobre estas plataformas suelen derivar en problemas colaterales
en la propia experiencia de usuario.</p>

<p>Desde mi punto de vista, en los tiempos que corren, esto es inaceptable.</p>

<p>Nosotros proponemos una plataforma pensada para los desarrolladores, pensada
y profundamente reflexionada. Esto no implica que el código deba estar bien
en una primera instancia, simplemente nuestra declaración de intenciones es
llevar el proyecto a un punto donde las empresas puedan confiar en el proyecto
para construir el suyo propio.</p>

<p>Os presentamos <a href="http://elcodi.io">Elcodi</a>.</p>

<p>En un planteamiento dividido en fases, justo estamos naciendo. Tenemos muy claro
cual es nuestro roadmap, por lo que en los próximos meses se desarrollaran las
principales features a nivel de core, así como la robustez necesaria como para
poder lidiar con colaboradores externos, que les guste el proyecto en su estado
inicial y que quieran acomparnos en este viaje, destinado a mejorar el estilo de
vida de los developers.</p>

<p>La plataforma está basada en Symfony2, y siguiendo la filosofía definida por el
propio framework, hemos enfocado la mayor parte de la arquitectura utilizando
una fuerte capa de eventos, desacoplando la mayoría de comportamientos y
componentes completamente.</p>

<p>Si eres programador Symfony, te propongo que almenos le eches un vistazo.
Verás errores, mil cosas a desarrollar y mil cosas a mejorar, pero como todo
proyecto, nuestra mayor ambición es la propia construcción del mismo, por lo que
es cuestión de meses, ganas y desarrollo.</p>

<p>Otro de nuestros objetivos es llegar a construir una buena documentación.
Tenemos esencialmente tres líneas de documentación en mente. Por un lado</p>

<p>queremos transmitir a los demás nuestra filosofía. La dirección que, sin duda
alguna, tomará el proyecto, independientemente de la implementación que este
adquiera en un momento dado. Es importante definir esto inicialmente porque al
final nos vincula muchísimo al target al que vamos destinados.</p>

<p>La documentación es algo lento, también sujeta a colaboraciones, y en principio
estará inicialmente solo en inglés.</p>

<p>Finalmente decir que elcodi.com es una empresa en plena expansión. Tenemos
buenas previsiones de crecimiento por lo que tenemos una garantía que lo que hoy
con tanta ilusión estamos empezando, no dejará de crecer.</p>

<p>Queremos que sea útil, queremos que nuestra propuesta esté a juicio de todo el
mundo y que saque vuestras críticas mas constructivas, solo así podremos
realmente hacer un proyecto interesante para todos.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom controller annotations]]></title>
    <link href="http://mmoreram.github.io/blog/2014/02/11/custom-controller-annotations/"/>
    <updated>2014-02-11T20:21:00+01:00</updated>
    <id>http://mmoreram.github.io/blog/2014/02/11/custom-controller-annotations</id>
    <content type="html"><![CDATA[<p>The goal is easy: To provide a very intuitive and easy way of creating
controller annotations in Symfony2.</p>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle">ControllerExtraBundle</a>
is both a set of annotations and a platform for creating new custom ones.
Actually, the bundle can create a new Entity, like ParamConverter does, with in
this case is just an empty Entity. The bundle also can create FormTypes, Forms
and FormViews with several options. Can also automate the doctrine <code>flush()</code>
action after the method execution or log something before / after every desired
action.</p>

<p>Bundle is still being tested in production environments, all feedback will be
very very useful.</p>

<p>Let&rsquo;s see how can we create our Annotations.</p>

<ul>
<li>Annotation</li>
<li>Resolver</li>
<li>Definition</li>
<li>Registration</li>
</ul>


<h2>Annotation</h2>

<p>The annotation object. You need to define the fields your custom annotation
will contain.
Must extends <code>Mmoreram\ControllerExtraBundle\Annotation\Abstracts\Annotation</code>
abstract class.</p>

<p>``` php
&lt;?php</p>

<p>namespace My\Bundle\Annotation;</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Abstracts\Annotation;</p>

<p>/<em>*
 * Entity annotation driver
 *
 * @Annotation
 </em>/
class MyCustomAnnotation extends Annotation
{</p>

<pre><code>/**
 * @var string
 *
 * Dummy field
 */
private $field;


/**
 * Get Dummy field
 *
 * @return string Dummy field
 */
public function getField()
{
    return $this-&gt;field;
}
</code></pre>

<p>}
```</p>

<h2>Resolver</h2>

<p>Once you have defined your own annotation, you have to resolve how this
annotation works in a controller. You can manage this using a Resolver. Must
extend <code>Mmoreram\ControllerExtraBundle\Resolver\Interfaces\AnnotationResolverInterface;</code>
abstract class.</p>

<p>``` php
&lt;?php</p>

<p>namespace My\Bundle\Resolver;</p>

<p>use Symfony\Component\HttpFoundation\Request;
use Mmoreram\ControllerExtraBundle\Resolver\Interfaces\AnnotationResolverInterface;
use Mmoreram\ControllerExtraBundle\Annotation\Abstracts\Annotation;</p>

<p>/<em>*
 * MyCustomAnnotation Resolver
 </em>/
class MyCustomAnnotationResolver implements AnnotationResolverInterface
{</p>

<pre><code>/**
 * Specific annotation evaluation.
 * This method MUST be implemented because is defined in the interface
 *
 * @param Request          $request    Request
 * @param Annotation       $annotation Annotation
 * @param ReflectionMethod $method     Method
 *
 * @return MyCustomAnnotationResolver self Object
 */
public function evaluateAnnotation(
                                    Request $request, 
                                    Annotation $annotation, 
                                    ReflectionMethod $method )
{
    /**
     * You can now manage your annotation.
     * You can acced to its fields using public methods.
     * 
     * Annotation fields can be public and can be acceded directly,
     * but is better for testing to use getters; they can be mocked.
     */
    $field = $annotation-&gt;getField();

    /**
     * You can also access to existing method parameters.
     * 
     * Available parameters are:
     * 
     * # ParamConverter parameters ( See `resolver_priority` config value )
     * # All method defined parameters, included Request object if is set.
     */
    $entity = $request-&gt;attributes-&gt;get('entity');

    /**
     * And you can now place new elements in the controller action.
     * In this example we are creating new method parameter
     * called $myNewField with some value
     */
    $request-&gt;attributes-&gt;set(
        'myNewField',
        new $field()
    );

    return $this;
}
</code></pre>

<p>}
```</p>

<p>This class will be defined as a service, so this method is computed just
before executing current controller. You can also subscribe to some kernel
events and do whatever you need to do ( You can check
<code>Mmoreram\ControllerExtraBundle\Resolver\LogAnnotationResolver</code> for some
examples.</p>

<h2>Definition</h2>

<p>Once Resolver is done, we need to define our service as an Annotation
Resolver. We will use a custom <code>tag</code>.</p>

<p>``` yml
parameters:</p>

<pre><code>#
# Resolvers
#
my.bundle.resolvers.my_custom_annotation_resolver.class: My\Bundle\Resolver\MyCustomAnnotationResolver
</code></pre>

<p>services:</p>

<pre><code>#
# Resolvers
#
my.bundle.resolvers.my_custom_annotation_resolver:
    class: %my.bundle.resolvers.my_custom_annotation_resolver.class%
    tags:
        - { name: controller_extra.annotation }
</code></pre>

<p>```</p>

<h2>Registration</h2>

<p>We need to register our annotation inside our application. We can just do it in
the <code>boot()</code> method of <code>bundle.php</code> file.</p>

<p>``` php
&lt;?php</p>

<p>namespace My\Bundle;</p>

<p>use Symfony\Component\HttpKernel\Bundle\Bundle;
use Doctrine\Common\Annotations\AnnotationRegistry;</p>

<p>/<em>*
 * MyBundle
 </em>/
class ControllerExtraBundle extends Bundle
{</p>

<pre><code>/**
 * Boots the Bundle.
 */
public function boot()
{
    $kernel = $this-&gt;container-&gt;get('kernel');

    AnnotationRegistry::registerFile($kernel
        -&gt;locateResource("@MyBundle/Annotation/MyCustomAnnotation.php")
    );
}
</code></pre>

<p>}
```</p>

<p><em>Et voilà!</em>  We can now use our custom Annotation in our project controllers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cache clear en Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2014/01/03/cache-clear-en-symfony2/"/>
    <updated>2014-01-03T15:11:00+01:00</updated>
    <id>http://mmoreram.github.io/blog/2014/01/03/cache-clear-en-symfony2</id>
    <content type="html"><![CDATA[<p>Vacía la caché de Symfony, y la vuelve a crear (sino se especifica lo contrario)</p>

<p><code>bash
$ php app/console cache:clear [--no-warmup] [--no-optional-warmers]
</code></p>

<p>Curioso comando existente en el framework Symfony2 desde sus inicios, y poco
utilizado por los proyectos. En realidad, he visto pocos proyectos que utilizen
este comando en los scripts de deploy, por lo que lo más habitual que veremos es
el clásico</p>

<p><code>bash
$ rm -Rf app/cache/*
</code></p>

<p>Pero es correcta esta práctica? Aunque parezca la forma más ágil de limpiar
cache, tengamos en cuenta que Symfony2 tiene procesos internos que muchos de
nosotros desconocemos por completo. Cuando ejecutamos el comando para vaciar
caché ( con la opción <code>--no-warmup</code> ) no tan solo vaciamos el directorio caché
sino que el framework ejecuta el método <code>clear()</code> de todos los servicios que
implementan la interface
<code>Symfony\Component\HttpKernel\CacheClearer\CacheClearerInterface</code> cuya
definición incorporen el tag <code>kernel.cache_clearer</code>.</p>

<p>En otras palabras.</p>

<p>``` yml
services:</p>

<pre><code>my_cache_clearer:
    class: Acme\MainBundle\Cache\MyClearer
    tags:
        - { name: kernel.cache_clearer }
</code></pre>

<p>```</p>

<p>Encontraréis mas información y especificación de estos tags
<a href="http://symfony.com/doc/current/reference/dic_tags.html#kernel-cache-clearer">aqui</a>.</p>

<h2>Reflexión</h2>

<p>En realidad es importante fijarse en la opción <code>--no-warmup</code> ya que es la que
cambia el comportamiento del comando. Cuando trabajamos en entornos de
producción, necesitamos que, en tiempo de deploy, nuestra aplicación tenga el
mínimo tiempo de downtime. Esto se consigue reduciendo al máximo el tiempo en
que una caché está vacía.</p>

<h3>Tabla básica de tiempos</h3>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1</li>
<li>[1-3] Deploy S1 &ndash;> S2</li>
<li>[3-4] Clear cache C1 from /cache</li>
<li>[4-7] Warm up new cache C2 into /cache_new</li>
<li>[7-8] Swap cache C1 &ndash;> C2. Rename /cache_new to /cache</li>
<li>[8]   Repository status: S2, Cache status: C2</li>
</ul>
</blockquote>

<h3>Problema 1</h3>

<p>Entre los tiempos 3 y 8, tenemos que /cache está vacía. Tenemos que tener en
cuenta que estamos en un entorno de producción, por lo que mientras hacemos el
proceso de deployment, nuestros servidores deben estar sirviendo peticiones en
todo momento.</p>

<p>Dado este caso, cada una de las peticiones se dará cuenta que la caché está
vacía, por lo que intentará volverla a montar desde cero. Deberíamos tener en
cuenta, entonces, que entre los tiempos 3 y 8, nuestro servicio estará caido.</p>

<p>De este análisis sacamos que debemos minimizar al máximo el tiempo pasado entre
el clear de la caché a invalidar y el switch a la nueva, o sea, reducir este
intervalo en el que nuestra caché está vacía.</p>

<p>Hace pocos dias propuse un
<a href="https://github.com/symfony/symfony/pull/9930">PR a FrameworkBundle</a> para
gestionar esto.</p>

<p>Lo único que hace es cambiar el orden entre el warm up de la nueva caché y el
clear de la vieja.</p>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1</li>
<li>[1-3] Deploy S1 &ndash;> S2</li>
<li>[3-6] Warm up new cache C2 into /cache_new</li>
<li>[6-7] Clear cache C1 from /cache</li>
<li>[7-8] Swap cache C1 &ndash;> C2. Rename /cache_new to /cache</li>
<li>[8]   Repository status: S2, Cache status: C2</li>
</ul>


<p>Downtime 2</p></blockquote>

<p>En este punto podemos ver que la ventana que separa el clear de la caché antigua
y el switch con la nueva solo es de dos unidades de tiempo, entre los tiempos 6
y 8. Ahora se nos plantea otro problema.</p>

<h3>Problema 2</h3>

<p>Hemos minimizado al máximo el tiempo de switch entre las dos caches, pero
seguimos teniendo una ventana de 5 unidades de tiempo entre que el repositorio
está en un estado S2 y la caché en un estado C1.</p>

<blockquote><p>Real downtime 5</p></blockquote>

<p>En realidad, dado este análisis solo podríamos actuar de una sola forma, y es
trabajar con un deployment paralelo ( como hace el warmup del cache:clear ).
Esto significa que nunca deployamos sobre nuestra instalación activa</p>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1 en /project</li>
<li>[1-8] Deployment Repository + cache:clear en /project_warmup</li>
<li>[8]   Repository status: S2, Cache status: C2 en /project_warmup</li>
<li>[8-9] Swap repository S1 &ndash;> S2. Rename /project to /project_warmup</li>
</ul>


<p>Downtime: 0</p></blockquote>

<h3>Problema 3</h3>

<p>En este caso es probable que nuestro proceso de deploy nos modifique elementos
externos, como puede ser ( y probablemente sea ) <code>mysql</code>. Entonces tendremos una
ventana bastante grande donde el modelo deployado en mysql que haga S2 no se
asemeje al modelo Doctrine de S1.</p>

<blockquote><p>Downtime: X</p></blockquote>

<p>So what? Como lo hacéis vosotros? Ya es por sondear un poco hacia donde tira la
gente&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic routes in Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2013/10/01/dynamic-routes-in-symfony2/"/>
    <updated>2013-10-01T18:30:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2013/10/01/dynamic-routes-in-symfony2</id>
    <content type="html"><![CDATA[<p>Given that most times we need to associate a static route entry with a method of
a controller, it is normal for Symfony developers are used to working with the
annotation @Route of FrameworkExtraBundle.</p>

<p>In some cases, it will be interesting or necessary to work with the router to
generate dynamic routes. This means that any bundle can generate a route from a
service, defining both the name of the route as all the information necessary
for the resolution of the route.</p>

<p>Consider the following example</p>

<p>``` php
&lt;?php</p>

<p>namespace Mmoreram\AcmeBundle\Router;</p>

<p>use Symfony\Component\Config\Loader\LoaderInterface;
use Symfony\Component\Config\Loader\LoaderResolverInterface;
use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\RouteCollection;</p>

<p>/<em>*
 * Acme dynamic router
 </em>/
class AcmeRoutesLoader implements LoaderInterface
{</p>

<pre><code>/**
 * @var boolean
 *
 * Route is loaded
 */
private $loaded = false;

/**
 * Loads a resource.
 *
 * @param mixed  $resource The resource
 * @param string $type     The resource type
 *
 * @return RouteCollection
 *
 * @throws RuntimeException Loader is added twice
 */
public function load($resource, $type = null)
{
    if ($this-&gt;loaded) {

        throw new \RuntimeException('Do not add this loader twice');
    }

    $routes = new RouteCollection();

    /**
     * url('controller_name') will point AcmeController:methodAction()
     */
    $routes-&gt;add('controller_name', new Route('controller/route', array(
        '_controller'   =&gt;  'AcmeBundle:Acme:method',
    )));

    $this-&gt;loaded = true;

    return $routes;
}

/**
 * Returns true if this class supports the given resource.
 *
 * @param mixed  $resource A resource
 * @param string $type     The resource type
 *
 * @return boolean This class supports the given resource
 */
public function supports($resource, $type = null)
{
    return 'acme' === $type;
}

/**
 * Gets the loader resolver.
 *
 * @return LoaderResolverInterface A LoaderResolverInterface instance
 */
public function getResolver()
{
}

/**
 * Sets the loader resolver.
 *
 * @param LoaderResolverInterface $resolver A LoaderResolverInterface
 */
public function setResolver(LoaderResolverInterface $resolver)
{
}
</code></pre>

<p>}
```</p>

<p>In method <code>supports()</code>, <code>$type</code> value can be any desired value, and only should
be defined once in all project.</p>

<p>As any service, we must define this class in dependency injection with specific
tag.</p>

<p>``` yml
services:</p>

<pre><code>acme.routes.loader:
    class: Mmoreram\AcmeBundle\Router\AcmeRoutesLoader
    tags:
        - { name: routing.loader }
</code></pre>

<p>```</p>

<p>And finally we just need to make our project know where to build our route, so
in <code>routing.yml</code> file we must add these lines.</p>

<p>``` yml
acme_routes:</p>

<pre><code>resource: .
type: acme
</code></pre>

<p>```</p>

<blockquote><p>At this point, type value must be the same as defined in Router service.</p></blockquote>
]]></content>
  </entry>
  
</feed>
