<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: symfony | Because yes]]></title>
  <link href="http://mmoreram.github.io/blog/categories/symfony/atom.xml" rel="self"/>
  <link href="http://mmoreram.github.io/"/>
  <updated>2015-08-23T18:17:18+02:00</updated>
  <id>http://mmoreram.github.io/</id>
  <author>
    <name><![CDATA[Marc Morera]]></name>
    <email><![CDATA[yuhu@mmoreram.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Elcodi wants you]]></title>
    <link href="http://mmoreram.github.io/blog/2014/07/21/elcodi-wants-you/"/>
    <updated>2014-07-21T21:28:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/07/21/elcodi-wants-you</id>
    <content type="html"><![CDATA[<p>Right. Elcodi wants you.</p>

<p><a href="http://elcodi.io">Elcodi Project</a></p>

<p>And Elcodi wants you because you are ambitious, a fighter, a ninja developer
eager to learn and to teach.</p>

<p>Elcodi wants you because you are a follower of good practices and have a sound
software craftsmanship mindset, because you are a perfectionist, because your
inspiring work is a way of life.</p>

<p>Elcodi wants you because you firmly believe that an open-source environment is a
trigger that can detonate personal and professional achievements.</p>

<p>We believe we are doing a good job. We are not alone in believing it, many
others do. This is why we have decided take it to the next level and start to
evolve, growing the team and our vision.</p>

<p>We really aim to make things the right way by unfolding the power of
collaborative software development and this is why we need your voice, your
ideas, your enthusiasm and, of course, we need your hands. Skillful, experienced
and visionary artisan hands.</p>

<p>If you share our vision and want to collaborate with a truly inspiring project,
contact me at <code>yuhu@mmoreram.com</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ControllerExtraBundle, some useful Controller annotations]]></title>
    <link href="http://mmoreram.github.io/blog/2014/06/30/controller-extra-bundle/"/>
    <updated>2014-06-30T17:03:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/06/30/controller-extra-bundle</id>
    <content type="html"><![CDATA[<p>Few days ago, at the bimonthly meeting of Symfony2 Barcelona, attendees
began to discuss the annotations. Obviously, given that it is a
practice that goes against many many philosophies or architectural strategies ,
many people were against them, and some people where I include myself, were in
favor.</p>

<p>Being in favor of annotations does not mean wanting to use everywhere
but take them into account when the occasion required it is.</p>

<p>We could divide Symfony2 project into two blocks in this case. the
first is the model, a set of elements that implement our domain.
Doctrine has some annotations to define how this model maps to the
database, and I admit that at the first, when you are in the lower part
and elemental learning curve, are very positive elements for all developers.</p>

<p>However, at the time that you must have actual control of your domain, and
the time domain may be used in more than one project and more than
a framework, we have a problem. So, and I will not go into details,
I conclude that annotations never should be used in the domain model.</p>

<p>On the other hand, we have the application, the entry point. The controllers.</p>

<p>Let me ask you a question.</p>

<p>Do you think your application will change its framework someday? And given that
the answer is affirmative&hellip; Do you think you will maintain your controllers?</p>

<p>Both questions can be answered affirmatively, but is a very very rarely
situation where, surely, most of you will never have to manage. So I think that
we should thread Controllers in a very different way than Model.</p>

<p>IMHO, I am used to using annotations, because simplifies a lot some repetitive
processes, and gives me a very visual definition of what my action is responding
against, and what configuration are being applied.</p>

<p>Maybe is not the best of the options in some cases, but if the annotations is
well documented and defined, maybe could be useful in lot of cases.</p>

<p>In Symfony Controllers we have those annotations (Surely there are more, but I
consider that those are the most useful of them)</p>

<ul>
<li>ParamConverter &ndash; Good annotation. The code is a little bit messy but I am very
thankful. At the point I needed to define the namespace of the entity through a
container parameter, this annotations became useless.</li>
<li>Method, Router y Template &ndash; Very useful for non-customizable projects. Worth
considering in our projects if we really do not need any kind of customization,
like custom routes.</li>
<li>Secure &ndash; Static. Very useful if you accept your controllers will never change
its secure definition.</li>
</ul>


<p>Given my little devotion for these controller annotations, some months ago I
decided to detect some needs I had in some personal projects, needs to repeat
some code once and again, code that had nothing to do with my business. I tried
to implement my annotations as flexible as possible.</p>

<p>For that I created <a href="https://github.com/mmoreram/ControllerExtraBundle">ControllerExtraBundle</a>.
This bundle, in addition to provide a set of Symfony2 annotations for
controllers, provides you a platform and a documentation to implement yourself
your own needs.</p>

<p>Actually this bundle is stable at version <code>v.1.1.2</code> and have this annotations</p>

<h2>@Paginator</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#paginator">@Paginator Documentation</a></p>

<p>Allows you to inject a Doctrine Paginator given a route and a configuration. Is
very flexible but has to evolve even more.</p>

<p><code>php
/**
 * Simple controller method
 *
 * This Controller matches pattern /paginate/nb/{limit}/{page}
 *
 * Where:
 *
 * * limit = 10
 * * page = 1
 *
 * @PaginatorAnnotation(
 *      class = (
 *          factoryClass = "Mmoreram\ControllerExtraBundle\Factory\EntityFactory",
 *          factoryMethod = "create",
 *          factoryStatic = true
 *      ),
 *      page = "~page~",
 *      limit = "~limit~",
 *      orderBy = {
 *          { "x", "createdAt", "ASC" },
 *          { "x", "updatedAt", "DESC" },
 *          { "x", "id", "0", {
 *              "1" = "ASC",
 *              "2" = "DESC",
 *          }}
 *      },
 *      wheres = {
 *          { "x", "enabled" , "=", true }
 *      },
 *      leftJoins = {
 *          { "x", "relation", "r" },
 *          { "x", "relation2", "r2" },
 *          { "x", "relation5", "r5", true },
 *      },
 *      innerJoins = {
 *          { "x", "relation3", "r3" },
 *          { "x", "relation4", "r4", true },
 *      },
 *      notNulls = {
 *          {"x", "address1"},
 *          {"x", "address2"},
 *      }
 * )
 */
public function indexAction(Paginator $paginator)
{
}
</code></p>

<h2>@Entity</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#entity">@Entity Documentation</a></p>

<p>Generates a new entity instance, given an entity definition. This definition can
be given a namespace, a container parameter, a doctrine shortcut or a factory
definition.</p>

<p>``` php
&lt;?php</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Entity;
use Mmoreram\ControllerExtraBundle\Entity\User;</p>

<p>/<em>*
 * Simple controller method
 *
 * This Controller matches pattern /user/edit/{id}/{username}
 *
 * @Entity(
 *      class = {
 *          &ldquo;factory&rdquo; = &ldquo;my.factory.service&rdquo;,
 *          &ldquo;method&rdquo;  = &ldquo;generate&rdquo;,
 *          &ldquo;static&rdquo;  = false,
 *      },
 *      name  = &ldquo;user&rdquo;
 * )
 </em>/
public function indexAction(User $user)
{</p>

<pre><code>// $user is an empty instance
</code></pre>

<p>}
```</p>

<p>You can also, and since some days ago, not only inject an empty entity instance
but retrieve an existing mapped instance like ParamConverter does, but in a very
easy way.</p>

<p>``` php
&lt;?php</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Entity;
use Mmoreram\ControllerExtraBundle\Entity\User;</p>

<p>/<em>*
 * Simple controller method
 *
 * This Controller matches pattern /user/edit/{id}/{username}
 *
 * @Entity(
 *      class = &ldquo;MmoreramCustomBundle:User&rdquo;,
 *      name  = &ldquo;user&rdquo;,
 *      mapping = {
 *          &ldquo;id&rdquo;: &ldquo;~id~&rdquo;,
 *          &ldquo;username&rdquo;: &ldquo;~username~&rdquo;
 *      }
 * )
 </em>/
public function indexAction(User $user)
{</p>

<pre><code>// $user is a mapped entity
</code></pre>

<p>}
```</p>

<h2>@Form</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#form">@Form Documentation</a></p>

<p>Generates a simple FormType, FormInterface of FormView instance, given a form
definition. You can also configure it to create given a mapped or a new entity
instance and you can also handleRequest it and validate.</p>

<p>To create it given a mapped or a new entity instance, you can combine it using
both @ParamConverter or @Entity annotations.</p>

<p>``` php
&lt;?php</p>

<p>use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\Form\Form;</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Form as AnnotationForm;
use Mmoreram\ControllerExtraBundle\Entity\User;</p>

<p>/<em>*
 * Simple controller method
 *
 * @Route(
 *      path = &ldquo;/user/{id}&rdquo;,
 *      name = &ldquo;view_user&rdquo;
 * )
 * @Entity(
 *      class = &ldquo;MmoreramCustomBundle:User&rdquo;,
 *      name  = &ldquo;user&rdquo;,
 *      mapping = {
 *          &ldquo;id&rdquo;: &ldquo;~id~&rdquo;
 *      }
 * )
 * @AnnotationForm(
 *      class         = &ldquo;user_type&rdquo;,
 *      entity        = &ldquo;user&rdquo;
 *      handleRequest = true,
 *      name          = &ldquo;userForm&rdquo;,
 *      validate      = &ldquo;isValid&rdquo;,
 * )
 </em>/
public function indexAction(User $user, Form $userForm, $isValid)
{
}
```</p>

<h2>@Flush</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#flush">@Flush Documentation</a></p>

<p>Allows you to automate a flush every time a response is returned. There are
some real philosophies that say that a single flush should be executed always
at the end of the request.</p>

<p>``` php
&lt;?php</p>

<p>use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Flush;
use Mmoreram\ControllerExtraBundle\Entity\Address;
use Mmoreram\ControllerExtraBundle\Entity\User;</p>

<p>/<em>*
 * Simple controller method
 *
 * @ParamConverter(&ldquo;user&rdquo;, class=&ldquo;MmoreramCustomBundle:User&rdquo;)
 * @ParamConverter(&ldquo;address&rdquo;, class=&ldquo;MmoreramCustomBundle:Address&rdquo;)
 * @Flush(
 *      entity = {
 *          &ldquo;user&rdquo;,
 *          &ldquo;address&rdquo;
 *      }
 * )
 </em>/
public function indexAction(User $user, Address $address)
{
}
```</p>

<h2>@JsonResponse</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#jsonresponse">@JsonResponse Documentation</a></p>

<p>This annotation converts your controller return value in a single response,
using your data serialized with php <code>json_encode()</code>. This follows same way
@Template does.</p>

<p>IMHO, very useful.</p>

<p>``` php
&lt;?php</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\JsonResponse;</p>

<p>/<em>*
 * Simple controller method
 *
 * @JsonResponse
 </em>/
public function indexAction(User $user, Address $address)
{</p>

<pre><code>return array(
    'This is my response'
);
</code></pre>

<p>}
```</p>

<h2>@Log</h2>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle#log">@Log Documentation</a></p>

<p>Automatic log system for controller methods. You can define level of your log
and the moment you want to do it (before, after, both)</p>

<p>``` php
&lt;?php</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Flush;</p>

<p>/<em>*
 * Simple controller method
 *
 * @Log(
 *      value   = &ldquo;Executing index Action&rdquo;,
 *      level   = @Log::LVL_WARNING
 * )
 </em>/
public function indexAction()
{
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Symfony Barcelona]]></title>
    <link href="http://mmoreram.github.io/blog/2014/06/25/symfony-barcelona/"/>
    <updated>2014-06-25T11:46:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/06/25/symfony-barcelona</id>
    <content type="html"><![CDATA[<p>Queridos developers de Barcelona y alrededores.</p>

<p>Como ya sabréis algunos, en Barcelona tenemos una comunidad muy interesante de
developers interesados en Symfony y Cervezas. Cada par de meses nos reunimos todos
en un bar y nos echamos un par de charlas relacionadas con nuestro entorno de
programación. Hablamos, bebemos como si no hubiera un mañana y nos intentamos
ayudar con aquellas cosas que nos interesan.</p>

<pre><code>- Hola, buenas tardes.
- Buenas tardes.
- ¿Y tu eres programador Symfony?
- Si claro.
- ¿Y vendrás a la próxima Symfony Barcelona?
- ¿Qué es esto?
</code></pre>

<p>Desde Symfony Barcelona queremos llegar a todos los developers PHP de la ciudad
que estamos aquí. Que existimos y que los queremos con nosotros.
(evidentemente no queremos ser centralistas, y ya que somos la única comunidad
symfony en Catalunya, todos los developers son bienvenidos, amados y queridos de
la misma forma)</p>

<p>Es por esto que invocamos el Dios del boca-a-boca para hacer del siguiente
evento Symfony algo nuevo para muchos y que encuentren un punto de encuentro
entre personas con los mismos problemas entre código.</p>

<p>Recordad que será el día 2 de Julio en el centro de Barcelona. Podéis apuntaros
en la página <a href="http://symfony-barcelona.es">Symfony Barcelona</a>, así como seguir
el usuario de twitter <a href="http://twitter.com/symfony_bcn">@symfony_bcn</a> y estar un
poco más al día de nuestros movimientos</p>

<p>En este caso tendremos una charla de Git, una de RabbitMQ, y finalmente
abriremos un debate entre todos los asistentes sobre un tema aún abierto (Podéis
dar vuestra opinión, propuestas, o mandarnos un cheque en blanco en el
<a href="https://groups.google.com/forum/#!topic/symfony_barcelona/vd7Ld5k3fpQ">grupo de google groups</a>)</p>

<p>Para la buena difusión del evento, recordad hacer (re)tweet del post, así como
ponerlo en las redes sociales, escribirlo a mano en un papel y ponerlo en las
patas de alguna paloma o en alguna botella surcadora de mares y horizontes.</p>

<p>Os esperamos a todos para brindar por esta comunidad tan molona :D</p>

<p>Salutacions!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ParamConverter... mala idea]]></title>
    <link href="http://mmoreram.github.io/blog/2014/05/05/paramconverter-una-mala-idea/"/>
    <updated>2014-05-05T13:18:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/05/05/paramconverter-una-mala-idea</id>
    <content type="html"><![CDATA[<p>Este problema ocurre en proyectos abiertos, open source. Para proyectos privados
donde Cart siempre será Cart, no creo que deba ser de su preocupación.</p>

<p>Cada vez tenemos más en mente trabajar con módulos que sean reutilizables. Las
buenas prácticas pasan por trabajar con interfaces y dar pie a que, el usuario
que tan amablemente está reutilizando nuestro código, pueda definir su dominio
según su especificación. Esto pasa, claro, por pensar que una entidad no siempre
será la misma entidad, el mismo objeto.</p>

<p>Me explicaré.</p>

<p>La buena práctica sugiere que cuando definimos una entidad con sus relaciones,
utilizemos un ResolveTargetEntityListener. Lo que hace este listener es, una vez
se han definido las relaciones utilizando interfaces, se resuelven éstas y se
sustituyen por entidades reales ( evidentemente por entidades que implementan
tales interfaces ).</p>

<p>Cuando se sigue esta estrategia, es natural definir tanto el namespace como
el factory de la entidad que estás utilizando en un parámetro de bundle, por lo
que se puede sobrescribir fácilmente en cada uno de los proyectos.</p>

<p>Vemos un ejemplo.</p>

<p>``` yml</p>

<p>Elcodi\CartBundle\Entity\Cart:</p>

<pre><code>type: entity
repositoryClass: Elcodi\CartBundle\Repository\CartRepository
table: cart

oneToOne:
    order:
        targetEntity: Elcodi\CartBundle\Entity\Interfaces\OrderInterface
        mappedBy: cart
</code></pre>

<p>```</p>

<p>En este caso, la relación con Order es débil, ya que la proponemos con cualquier
entidad que implemente OrderInterface. Solo hace falta que el
ResolveTargetEntityListener proponga una implementación para OrderInterface, en
nuestro caso, <code>Elcodi\CartBundle\Entity\Order</code>.</p>

<p>En nuestro config, definimos los namespaces de las entidades con las que vamos a
trabajar.</p>

<p>``` yml</p>

<p>parameters:</p>

<pre><code>#
# Entities
#
elcodi.core.cart.entity.cart.class: Elcodi\CartBundle\Entity\Cart
elcodi.core.cart.entity.order.class: Elcodi\CartBundle\Entity\Order

#
# Factories
#
elcodi.core.cart.factory.cart.class: Elcodi\CartBundle\Factory\CartFactory
elcodi.core.cart.factory.order.class: Elcodi\CartBundle\Factory\OrderFactory
</code></pre>

<p>```</p>

<p>Este escenario anuncia lo que el título de este post enuncia. Hardcodear el
namespace de una entidad en alguna parte, rompe toda esta estrategia. Si
trabajamos de esta forma &ldquo;abstracta&rdquo; no nos podemos permitir el lujo de marcar
con sangre que una entidad siempre será de un tipo específico, y es, en
realidad, lo que obliga el ParamConverter</p>

<p>``` php</p>

<p>use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;</p>

<p>/<em>*
 * @Route(&ldquo;/cart/{id}&rdquo;)
 * @ParamConverter(&ldquo;cart&rdquo;, class=&ldquo;ElcodiCartBundle:Cart&rdquo;)
 </em>/
public function showAction(Post $post)
{
}</p>

<p>```</p>

<p>Proposición</p>

<p>Para que el ParamConverter funcionara de tal forma que pudiéramos salvar este
problema, deberíamos poder definir nuestra entidad con un parameter. Algo así:</p>

<p>``` php</p>

<p>use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;</p>

<p>/<em>*
 * @Route(&ldquo;/cart/{id}&rdquo;)
 * @ParamConverter(&ldquo;cart&rdquo;, class=&ldquo;%elcodi.core.cart.entity.cart.class%&rdquo;)
 </em>/
public function showAction(Post $post)
{
}</p>

<p>```</p>

<p>Esto implica que se debería inyectar el Container entero en el servicio que
trabaja los paramconverter de Doctrine, y que deberíamos checkear siempre si
el parámetro que se pasa es un namespace o un nombre de un parámetro.</p>

<p>Tal vez tendría sentido poder trabajar con ExpressionLanguage, pero el problema
es que añades una relación mas al bundle, por lo que no creo que les guste a los
autores del bundle ( SensioLabs ).</p>

<p>Con este post no quiero abrir un debate sobre si las annotations están bien o
no. Soy el primero que las he defendido en su momento, otorgando siempre su
utilidad en ciertos entornos y en ciertos casos. Ahora que empiezo a trabajar en
un entorno 100% OpenSource ya no valen tanto como antes.</p>

<p>Que creéis al respecto? Olvidaríais las annotations al 100 en entornos Open
Source?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elcodi, a new Symfony adventure]]></title>
    <link href="http://mmoreram.github.io/blog/2014/04/29/elcodi-a-new-symfony-adventure/"/>
    <updated>2014-04-29T16:10:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/04/29/elcodi-a-new-symfony-adventure</id>
    <content type="html"><![CDATA[<p>Some changes are about to come. And it seems that they are good
changes. I haven’t written in my blog for a few weeks, and the truth is
I feel bad about it. I like to write about the things that happen to me at
the company; about the problems we find and the solutions I come up
with. The thing is that, for some months now, I’ve been really focused
on the project that we are launching to the world today. Initially, it is
a project by developers for developers, focused on meeting the actual
needs of developers who design and program e-commerce.</p>

<p>It is true that we have plenty of platforms and options to develop e-
commerce around the world. I could name a few, and probably they all
have outstanding metrics and KPIs.</p>

<p>The problem with these platforms is that they are entirely B2B, so
they only make sense when the end user just needs to have a good
management, installation and configuration interface; and when
technical departments want to develop, both horizontally (new features
for things already in use, or just customization) and vertically (new
features), these B2B platforms fall short, and so the company must
either pay a lot of money in refactoring, or the existing code must be
touched, contaminating it and putting its integrity at risk.</p>

<p>These platforms are usually not tested, and so each line added is
potentially harmful for the whole system. Then, each development
on these platforms usually results in collateral problems in the user
experience itself.</p>

<p>As I see it, this is unacceptable in our times.
We propose a platform conceived for developers, thought of and deeply
reflected on. This does not mean that the code is right from the very
start; our declaration of intent is simply to take this project to a certain
point where companies can trust in the project in order to build their
own.</p>

<p>We present you <a href="http://elcodi.io">Elcodi</a>.</p>

<p>We are just beginning to emerge with an approach divided into phases.
Our roadmap is very clear to us, and so in the next few months we
will develop the main features at a core level, as well as the necessary
robustness in order to deal with any outsourcers who like the project in
its initial stage and wish to join us in this journey, aimed at improving
the lifestyle of developers.</p>

<p>The platform is based on Symfony2 and, following the philosophy
defined by its own framework, we have focused most of the
architecture by using a strong layer of events, fully uncoupling most
behaviours and components.</p>

<p>If you are a Symfony programmer, I suggest that you check it out. You
will see errors, a thousand things left to develop and to improve; but,
like with all projects, our greatest ambition is its own construction;
therefore, it’s a matter of months, energy and development.
Another of our objectives is building a good documentation.</p>

<p>Essentially, we have three documentation lines in mind. Firstly, we
want to communicate our philosophy to other people; the direction
the project will undoubtedly take, regardless of its implementation
in a given moment. It is important to define this from the beginning,
because to a great extent it links us to our target audience.
Documentation is a slow process, which is also subject to collaboration,
and at first it will be in English only.</p>

<p>Finally, I should say that elcodi.com is a rapidly expanding company.
We have good growth projections, and so we are certain that what we
are starting today with such enthusiasm will not cease to grow.
We want it to be useful; we want our proposal to be seen by everybody,
to get your most constructive criticism, since only in this way we can
really make an interesting project for us all.</p>
]]></content>
  </entry>
  
</feed>
