<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Symfony | Because yes]]></title>
  <link href="http://mmoreram.github.io/blog/categories/symfony/atom.xml" rel="self"/>
  <link href="http://mmoreram.github.io/"/>
  <updated>2015-04-25T17:28:54+02:00</updated>
  <id>http://mmoreram.github.io/</id>
  <author>
    <name><![CDATA[Marc Morera]]></name>
    <email><![CDATA[yuhu@mmoreram.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bye Bye Symfony]]></title>
    <link href="http://mmoreram.github.io/blog/2014/09/01/bye-bye-symfony/"/>
    <updated>2014-09-01T00:00:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/09/01/bye-bye-symfony</id>
    <content type="html"><![CDATA[<p>Don&rsquo;t be afraid. You know what I think about the Symfony components and how I
love them. Until now any circumstance has changed my mind about using them in my
projects, and over the time, after discover every hidden single piece of code, I
have turned more amazed of their power.</p>

<p>The reason of this post is just to tell you, with a simple example, how to say
<em>Bye Bye, Symfony!</em> and say <em>Hi PHP!</em>. This really means uncouple from Symfony
Components and still use them as the default implementation, while we can
securely remove, from the composer <em>require</em> block, our Symfony dependencies.</p>

<p>One of the poor things I have heard these last months has been the word <em>you must</em>
or <em>you should</em> event without knowing exactly what is the real direction of my
project, so every word in this post will be just an idea you could have in mind
when you design your own architecture, thinking about your real needs, far from
the things you should or you must do.</p>

<p>To explain that, how we can say goodbye to Symfony, we will start with a simple
example. A simple class we could find in every project. Our class will have no
sense but will be useful in our specific example, helping us to understand what
is all this about.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#x6d;&#97;&#x69;&#x6c;&#x74;&#x6f;&#x3a;&#121;&#117;&#104;&#117;&#64;&#109;&#109;&#x6f;&#114;&#101;&#x72;&#x61;&#x6d;&#46;&#99;&#111;&#109;">&#x79;&#117;&#x68;&#117;&#64;&#x6d;&#x6d;&#x6f;&#114;&#101;&#114;&#x61;&#x6d;&#x2e;&#99;&#x6f;&#x6d;</a>
 </em>/</p>

<p>namespace Package\Generator;</p>

<p>use Symfony\Component\Routing\Generator\UrlGeneratorInterface;</p>

<p>/<em>*
 * Class UrlPrinter
 </em>/
class UrlPrinter
{</p>

<pre><code>/**
 * @var UrlGeneratorInterface
 *
 * Url generator
 */
protected $urlGenerator;

/**
 * Construct method
 *
 * @param UrlGeneratorInterface $urlGenerator Url generator
 */
public function __construct(UrlGeneratorInterface $urlGenerator)
{
    $this-&gt;urlGenerator = $urlGenerator;
}

/**
 * Generates Homepage route and print complete path
 *
 * @return string Route path
 */
public function printHomePageRoute()
{
    return $this
        -&gt;urlGenerator
        -&gt;generate('homepage');
}
</code></pre>

<p>}
```</p>

<p>As we can see, use this class means use <code>UrlGeneratorInterface</code>. This class is
part of the Symfony Routing Component, so is a really bad idea if you really
want to make your project multi-environment</p>

<p>Is that good? Well, it depends on your both product requirements and technical
requirements. If you want to use always the Symfony router component, this piece
of code is good enough. Otherwise, If you want to use another router, you have a
problem.</p>

<p>Say your project must work with and without Symfony. Our class should not depend
on this interface. One of the strategies to uncouple external implementations is
using ports and adapters.</p>

<p>I will explain how it works and how we can implement it.</p>

<h2>Real life example</h2>

<p>Let&rsquo;s imagine we want to sell an USB device. We have decided in our product
definition that this device will connect to external devices using USB Standard
A (the big one). One of the possible approaches would be to design our device
with the external connector coupled. This means selling it with the USB wire
(like an USB camera, for example).</p>

<p>But why coupling our device with an specific output? Do you know what it really
means?</p>

<ul>
<li>If the wire breaks, we must change all the device.</li>
<li>You can connect with devices that accept only USB-A</li>
<li>Wire improvements means new device versions.</li>
</ul>


<p>What would be an alternative decision? Well, why don&rsquo;t we focus our efforts in
the camera and we just let other companies to help us with the wire? This means
more flexibility for the final user and capability of removing and changing the
cable when is broken. And&hellip; they could connect their camera to many different
formats, even for the most adventurous, their own formats.</p>

<p>So, in fact, our device should have one female USB port with an specification
of how connect it with another device. The wire would be just an adapter of our
device so many of them could be plugged-in.</p>

<p>We have talked about devices, ports, adapters, specifications, but&hellip; how can
this help me with my project? Is that hard?</p>

<p>The answer is No.</p>

<h2>Solution</h2>

<p>Our goal is to create an specification for URL generators and force each adapter
to implement it in their own way. As we know, the OOP languages resolve the
specification with the interfaces.</p>

<p>Let&rsquo;s create our specification.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#109;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#121;&#117;&#104;&#117;&#64;&#x6d;&#109;&#x6f;&#x72;&#x65;&#x72;&#x61;&#109;&#46;&#99;&#111;&#109;">&#121;&#117;&#x68;&#117;&#64;&#109;&#x6d;&#111;&#114;&#x65;&#x72;&#97;&#109;&#46;&#99;&#111;&#x6d;</a>
 </em>/</p>

<p>namespace Package\Specification;</p>

<p>/<em>*
 * Interface PackageUrlGeneratorInterface
 </em>/
interface PackageUrlGeneratorInterface
{</p>

<pre><code>/**
 * Generates a route given its name.
 *
 * @return string Route path
 */
public function generateUrl($routeName);
</code></pre>

<p>}
<code>``
We are just specifying. We want that, whatever is the implementation, each
adapter must fulfill this rule: Has a method called</code>generateRoute` that, given
the route name, will return its complete path.</p>

<p>Let&rsquo;s adapt our UrlPrinter to work with specification instead of implementation.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#121;&#x75;&#104;&#117;&#x40;&#109;&#109;&#111;&#114;&#x65;&#114;&#97;&#x6d;&#x2e;&#x63;&#x6f;&#x6d;">&#121;&#117;&#x68;&#x75;&#64;&#x6d;&#109;&#x6f;&#x72;&#101;&#x72;&#97;&#x6d;&#x2e;&#99;&#111;&#x6d;</a>
 </em>/</p>

<p>namespace Package\Generator;</p>

<p>use Package\Specification\PackageUrlGeneratorInterface;</p>

<p>/<em>*
 * Class UrlPrinter
 </em>/
class UrlPrinter
{</p>

<pre><code>/**
 * @var PackageUrlGeneratorInterface
 *
 * Url generator
 */
protected $urlGenerator;

/**
 * Construct method
 *
 * @param UrlGeneratorInterface $urlGenerator Url generator
 */
public function __construct(PackageUrlGeneratorInterface $urlGenerator)
{
    $this-&gt;urlGenerator = $urlGenerator;
}

/**
 * Generates Homepage route and print complete path
 *
 * @return string Route path
 */
public function printHomePageRoute()
{
    return $this
        -&gt;urlGenerator
        -&gt;generateUrl('homepage');
}
</code></pre>

<p>}
```</p>

<p>Now, our UrlPrinter does not depends on any external library. Goal reached!</p>

<p>But, now what? I mean, we should implement our adapter, am I right? What is a
camera with a great specification and without wire plugged in? (A wireless
camera, welcome to the twenty century ^^. Just joking)</p>

<p>Our UrlPrinter needs a <em>PackageUrlGeneratorInterface</em> implementation to be
built, so we have to implement an adapter. And because we still want to work with
Symfony Routing Component as my first option, we will create the Symfony Adapter
for my specification.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#109;&#97;&#x69;&#108;&#116;&#111;&#x3a;&#121;&#117;&#104;&#x75;&#x40;&#109;&#109;&#111;&#114;&#x65;&#x72;&#97;&#109;&#x2e;&#x63;&#x6f;&#x6d;">&#x79;&#x75;&#104;&#117;&#x40;&#x6d;&#x6d;&#x6f;&#x72;&#101;&#x72;&#x61;&#109;&#46;&#x63;&#x6f;&#x6d;</a>
 </em>/</p>

<p>namespace Package\Adapter;</p>

<p>use Package\Specification\PackageUrlGeneratorInterface;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;</p>

<p>/<em>*
 * Class SymfonyUrlGeneratorAdapter
 </em>/
class SymfonyUrlGeneratorAdapter implements PackageUrlGeneratorInterface
{</p>

<pre><code>/**
 * @var UrlGeneratorInterface
 *
 * Url generator
 */
protected $urlGenerator;

/**
 * Construct method
 *
 * @param UrlGeneratorInterface $urlGenerator Url generator
 */
public function __construct(UrlGeneratorInterface $urlGenerator)
{
    $this-&gt;urlGenerator = $urlGenerator;
}

/**
 * Generates a route given its name
 *
 * @return string Route path
 */
public function generateUrl($routeName)
{
    $this
        -&gt;urlGenerator
        -&gt;generate($routeName);
}
</code></pre>

<p>}
```</p>

<p>This an adapter, my friends. Each adapter has one mission, and is just transform
the way we understand the method <code>generateUrl</code> must work (specification) to the
way each external project understands it (implementation). In this case, very
easy, our <code>generateUrl</code> is the same as Symfony Router Component&rsquo;s <code>generate</code>.</p>

<p>Symfony Component is now required by this adapter, but because we are not
required to use this adapter (Maybe we can use a dummy one for our tests, or a
mocked one), Symfony Component is not required by our package anymore, just
suggested.</p>

<p>Let&rsquo;s see another Adapter implementation, requiring another external library.</p>

<p>``` php
&lt;?php</p>

<p>/<em>*
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 *
 * Feel free to edit as you please, and have fun.
 *
 * @author Marc Morera <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x79;&#x75;&#x68;&#117;&#x40;&#109;&#x6d;&#111;&#114;&#101;&#114;&#x61;&#x6d;&#x2e;&#x63;&#111;&#x6d;">&#121;&#x75;&#104;&#x75;&#64;&#x6d;&#109;&#111;&#x72;&#x65;&#x72;&#97;&#109;&#46;&#x63;&#x6f;&#x6d;</a>
 </em>/</p>

<p>namespace Package\Adapter;</p>

<p>use Package\Specification\PackageUrlGeneratorInterface;
use AnotherProject\UrlGeneratorInterface;</p>

<p>/<em>*
 * Class SymfonyUrlGeneratorAdapter
 </em>/
class SymfonyUrlGeneratorAdapter implements PackageUrlGeneratorInterface
{</p>

<pre><code>/**
 * @var UrlGeneratorInterface
 *
 * Url generator
 */
protected $urlGenerator;

/**
 * Construct method
 *
 * @param UrlGeneratorInterface $urlGenerator Url generator
 */
public function __construct(UrlGeneratorInterface $urlGenerator)
{
    $this-&gt;urlGenerator = $urlGenerator;
}

/**
 * Generates a route given its name
 *
 * @return string Route path
 */
public function generateUrl($routeName)
{
    $routeName = '_' . $routeName;

    $this
        -&gt;urlGenerator
        -&gt;anotherGenerateMethod($routeName);
}
</code></pre>

<p>}
```</p>

<p>Both adapters would be placed in the <code>Adapter/</code> folder, and the final user
should be able to switch them and even implement new ones.</p>

<h2>From require to suggest</h2>

<p>With our changes, we can remove &ldquo;symfony/routing&rdquo; from the require block and add
it into the suggest block in <code>composer.json</code> file.</p>

<p>``` yml
&ldquo;require&rdquo;: {</p>

<pre><code>"php": "&gt;=5.4",
...
</code></pre>

<p>},
&ldquo;suggest&rdquo;: {</p>

<pre><code>"symfony/routing": "Required if using Routing adapter",
"mmoreram/another-project": Required if using AnotherProject Routing adapter"
</code></pre>

<p>},
```</p>

<p>We will only require the packages needed by the adapter we are using.</p>

<h2>What we win</h2>

<p>Much. We win maximum implementation flexibility and minimum coupling. Would be
wise to say that a PHP project should tend to this thought, but once again, it
depends on many factors.</p>

<h2>What we lose</h2>

<p>It Depends. If you want your project to be understandable by a lot of developing
knowledge levels, this architecture goes away from the comprehensibility of a
simple code. You also can lose by having lot of files, so you should respect
some kind of best practices code, to make people working on your project
comfortable dealing with it.</p>

<h2>Best practices</h2>

<p>I should talk about <em>Marc practices</em> instead of <em>Best practices</em>. I am used to
adding my adapters always in the folder <code>/Adapter/{PortName}/</code>, being <em>PortName</em>
the name of the port we are dealing with in camel case format. In this case, we
should add both adapters in <code>/Adapter/UrlGenerator/</code>.</p>

<p>Given this format we can determine what adapters we can use in our project in a
very agile way.</p>

<h2>Reference projects</h2>

<p>First project that comes in my mind when I think about Ports/Adapters is
<a href="https://github.com/KnpLabs/Gaufrette/tree/master/src/Gaufrette">Gaufrette</a>, a
filesystem abstraction layer with a lot of adapters implemented.</p>

<p>In <a href="https://github.com/elcodi/elcodi">Elcodi</a> we are actually using this
library and its really awesome how easy is using it.</p>

<p>We have also implemented internally some features using this architecture, for
example, the <a href="https://github.com/elcodi/elcodi/tree/master/src/Elcodi/Component/Geo/Adapter/Populator">Geo Schema Populator</a>,
a new feature under development that will allow you to populate all Geo schema
using some adapters. Right now only GeoData adapter is implemented.</p>

<p>Another example, the
<a href="https://github.com/elcodi/elcodi/tree/master/src/Elcodi/Component/Currency/Adapter/CurrencyExchangeRatesProvider">Currency Exchange Rates Populator</a>
with OpenExchangeRates implementation already done.</p>

<h2>Final thoughts</h2>

<p>Using ports and adapters is really a great tool for those who want to uncouple
from implementations and a great pattern if you develop open source. Open source
should satisfy as people as possible, so remember, specify and then implement.</p>

<p>Try it and then tell us your experience :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Elcodi, una nueva aventura en Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2014/04/17/elcodi/"/>
    <updated>2014-04-17T12:46:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2014/04/17/elcodi</id>
    <content type="html"><![CDATA[<p>Ciertos cambios están por llegar. Y parece ser que son cambios buenos. Llevo
unas cuantas semanas sin escribir en el blog, y la verdad es que me sabe mal.
Me gusta contar cosas que me van sucediendo en la empresa. Problemas que nos
vamos encontrando y soluciones que se me van ocurriendo. El problema es que
llevo unos meses muy centrado en el proyecto que justo hoy lanzamos al mundo.
Es un proyecto inicialmente de desarrolladores para desarrolladores, centrado en
cubrir necesidades reales de los developers destinados a diseñar y
programar ecommerces.</p>

<p>Es cierto que tenemos muchísimas plataformas y opciones para desarrollar
ecommerces alrededor del mundo. Podría enumerar unos cuantos, y probablemente
todos tengan unas métricas y unos KPIs magníficos.</p>

<p>Los problemas de estas plataformas es que son completamente B2B, por lo que tienen sentido cuando
el usuario final simplemente debe tener una buena interfaz de administración,
de instalación y de configuración; y que cuando los departamentos técnicos quieren
desarrollar, tanto horizontalmente ( nuevas funcionalidades de
aquello que ya se está utilizando, o simplemente customizar ) como verticalmente
( nuevas funcionalidades ), estas plataformas B2B se quedan
cortas, por lo que la empresa tiene que desembolsar una cantidad enorme de
dinero en un refáctoring, o simplemente, se debe empezar a todar el código
existente, ensuciándolo y haciendo peligrar su integridad.</p>

<p>Estas plataformas no suelen estar testeadas, por lo que cada línea que se añade
es una línea potencialmente dañina para todo el sistema, con lo que cada
desarrollo sobre estas plataformas suelen derivar en problemas colaterales
en la propia experiencia de usuario.</p>

<p>Desde mi punto de vista, en los tiempos que corren, esto es inaceptable.</p>

<p>Nosotros proponemos una plataforma pensada para los desarrolladores, pensada
y profundamente reflexionada. Esto no implica que el código deba estar bien
en una primera instancia, simplemente nuestra declaración de intenciones es
llevar el proyecto a un punto donde las empresas puedan confiar en el proyecto
para construir el suyo propio.</p>

<p>Os presentamos <a href="http://elcodi.io">Elcodi</a>.</p>

<p>En un planteamiento dividido en fases, justo estamos naciendo. Tenemos muy claro
cual es nuestro roadmap, por lo que en los próximos meses se desarrollaran las
principales features a nivel de core, así como la robustez necesaria como para
poder lidiar con colaboradores externos, que les guste el proyecto en su estado
inicial y que quieran acomparnos en este viaje, destinado a mejorar el estilo de
vida de los developers.</p>

<p>La plataforma está basada en Symfony2, y siguiendo la filosofía definida por el
propio framework, hemos enfocado la mayor parte de la arquitectura utilizando
una fuerte capa de eventos, desacoplando la mayoría de comportamientos y
componentes completamente.</p>

<p>Si eres programador Symfony, te propongo que almenos le eches un vistazo.
Verás errores, mil cosas a desarrollar y mil cosas a mejorar, pero como todo
proyecto, nuestra mayor ambición es la propia construcción del mismo, por lo que
es cuestión de meses, ganas y desarrollo.</p>

<p>Otro de nuestros objetivos es llegar a construir una buena documentación.
Tenemos esencialmente tres líneas de documentación en mente. Por un lado</p>

<p>queremos transmitir a los demás nuestra filosofía. La dirección que, sin duda
alguna, tomará el proyecto, independientemente de la implementación que este
adquiera en un momento dado. Es importante definir esto inicialmente porque al
final nos vincula muchísimo al target al que vamos destinados.</p>

<p>La documentación es algo lento, también sujeta a colaboraciones, y en principio
estará inicialmente solo en inglés.</p>

<p>Finalmente decir que elcodi.com es una empresa en plena expansión. Tenemos
buenas previsiones de crecimiento por lo que tenemos una garantía que lo que hoy
con tanta ilusión estamos empezando, no dejará de crecer.</p>

<p>Queremos que sea útil, queremos que nuestra propuesta esté a juicio de todo el
mundo y que saque vuestras críticas mas constructivas, solo así podremos
realmente hacer un proyecto interesante para todos.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Custom controller annotations]]></title>
    <link href="http://mmoreram.github.io/blog/2014/02/11/custom-controller-annotations/"/>
    <updated>2014-02-11T20:21:00+01:00</updated>
    <id>http://mmoreram.github.io/blog/2014/02/11/custom-controller-annotations</id>
    <content type="html"><![CDATA[<p>The goal is easy: To provide a very intuitive and easy way of creating
controller annotations in Symfony2.</p>

<p><a href="https://github.com/mmoreram/ControllerExtraBundle">ControllerExtraBundle</a>
is both a set of annotations and a platform for creating new custom ones.
Actually, the bundle can create a new Entity, like ParamConverter does, with in
this case is just an empty Entity. The bundle also can create FormTypes, Forms
and FormViews with several options. Can also automate the doctrine <code>flush()</code>
action after the method execution or log something before / after every desired
action.</p>

<p>Bundle is still being tested in production environments, all feedback will be
very very useful.</p>

<p>Let&rsquo;s see how can we create our Annotations.</p>

<ul>
<li>Annotation</li>
<li>Resolver</li>
<li>Definition</li>
<li>Registration</li>
</ul>


<h2>Annotation</h2>

<p>The annotation object. You need to define the fields your custom annotation
will contain.
Must extends <code>Mmoreram\ControllerExtraBundle\Annotation\Abstracts\Annotation</code>
abstract class.</p>

<p>``` php
&lt;?php</p>

<p>namespace My\Bundle\Annotation;</p>

<p>use Mmoreram\ControllerExtraBundle\Annotation\Abstracts\Annotation;</p>

<p>/<em>*
 * Entity annotation driver
 *
 * @Annotation
 </em>/
class MyCustomAnnotation extends Annotation
{</p>

<pre><code>/**
 * @var string
 *
 * Dummy field
 */
private $field;


/**
 * Get Dummy field
 *
 * @return string Dummy field
 */
public function getField()
{
    return $this-&gt;field;
}
</code></pre>

<p>}
```</p>

<h2>Resolver</h2>

<p>Once you have defined your own annotation, you have to resolve how this
annotation works in a controller. You can manage this using a Resolver. Must
extend <code>Mmoreram\ControllerExtraBundle\Resolver\Interfaces\AnnotationResolverInterface;</code>
abstract class.</p>

<p>``` php
&lt;?php</p>

<p>namespace My\Bundle\Resolver;</p>

<p>use Symfony\Component\HttpFoundation\Request;
use Mmoreram\ControllerExtraBundle\Resolver\Interfaces\AnnotationResolverInterface;
use Mmoreram\ControllerExtraBundle\Annotation\Abstracts\Annotation;</p>

<p>/<em>*
 * MyCustomAnnotation Resolver
 </em>/
class MyCustomAnnotationResolver implements AnnotationResolverInterface
{</p>

<pre><code>/**
 * Specific annotation evaluation.
 * This method MUST be implemented because is defined in the interface
 *
 * @param Request          $request    Request
 * @param Annotation       $annotation Annotation
 * @param ReflectionMethod $method     Method
 *
 * @return MyCustomAnnotationResolver self Object
 */
public function evaluateAnnotation(
                                    Request $request, 
                                    Annotation $annotation, 
                                    ReflectionMethod $method )
{
    /**
     * You can now manage your annotation.
     * You can acced to its fields using public methods.
     * 
     * Annotation fields can be public and can be acceded directly,
     * but is better for testing to use getters; they can be mocked.
     */
    $field = $annotation-&gt;getField();

    /**
     * You can also access to existing method parameters.
     * 
     * Available parameters are:
     * 
     * # ParamConverter parameters ( See `resolver_priority` config value )
     * # All method defined parameters, included Request object if is set.
     */
    $entity = $request-&gt;attributes-&gt;get('entity');

    /**
     * And you can now place new elements in the controller action.
     * In this example we are creating new method parameter
     * called $myNewField with some value
     */
    $request-&gt;attributes-&gt;set(
        'myNewField',
        new $field()
    );

    return $this;
}
</code></pre>

<p>}
```</p>

<p>This class will be defined as a service, so this method is computed just
before executing current controller. You can also subscribe to some kernel
events and do whatever you need to do ( You can check
<code>Mmoreram\ControllerExtraBundle\Resolver\LogAnnotationResolver</code> for some
examples.</p>

<h2>Definition</h2>

<p>Once Resolver is done, we need to define our service as an Annotation
Resolver. We will use a custom <code>tag</code>.</p>

<p>``` yml
parameters:</p>

<pre><code>#
# Resolvers
#
my.bundle.resolvers.my_custom_annotation_resolver.class: My\Bundle\Resolver\MyCustomAnnotationResolver
</code></pre>

<p>services:</p>

<pre><code>#
# Resolvers
#
my.bundle.resolvers.my_custom_annotation_resolver:
    class: %my.bundle.resolvers.my_custom_annotation_resolver.class%
    tags:
        - { name: controller_extra.annotation }
</code></pre>

<p>```</p>

<h2>Registration</h2>

<p>We need to register our annotation inside our application. We can just do it in
the <code>boot()</code> method of <code>bundle.php</code> file.</p>

<p>``` php
&lt;?php</p>

<p>namespace My\Bundle;</p>

<p>use Symfony\Component\HttpKernel\Bundle\Bundle;
use Doctrine\Common\Annotations\AnnotationRegistry;</p>

<p>/<em>*
 * MyBundle
 </em>/
class ControllerExtraBundle extends Bundle
{</p>

<pre><code>/**
 * Boots the Bundle.
 */
public function boot()
{
    $kernel = $this-&gt;container-&gt;get('kernel');

    AnnotationRegistry::registerFile($kernel
        -&gt;locateResource("@MyBundle/Annotation/MyCustomAnnotation.php")
    );
}
</code></pre>

<p>}
```</p>

<p><em>Et voilà!</em>  We can now use our custom Annotation in our project controllers.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cache clear en Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2014/01/03/cache-clear-en-symfony2/"/>
    <updated>2014-01-03T15:11:00+01:00</updated>
    <id>http://mmoreram.github.io/blog/2014/01/03/cache-clear-en-symfony2</id>
    <content type="html"><![CDATA[<p>Vacía la caché de Symfony, y la vuelve a crear (sino se especifica lo contrario)</p>

<p><code>bash
$ php app/console cache:clear [--no-warmup] [--no-optional-warmers]
</code></p>

<p>Curioso comando existente en el framework Symfony2 desde sus inicios, y poco
utilizado por los proyectos. En realidad, he visto pocos proyectos que utilizen
este comando en los scripts de deploy, por lo que lo más habitual que veremos es
el clásico</p>

<p><code>bash
$ rm -Rf app/cache/*
</code></p>

<p>Pero es correcta esta práctica? Aunque parezca la forma más ágil de limpiar
cache, tengamos en cuenta que Symfony2 tiene procesos internos que muchos de
nosotros desconocemos por completo. Cuando ejecutamos el comando para vaciar
caché ( con la opción <code>--no-warmup</code> ) no tan solo vaciamos el directorio caché
sino que el framework ejecuta el método <code>clear()</code> de todos los servicios que
implementan la interface
<code>Symfony\Component\HttpKernel\CacheClearer\CacheClearerInterface</code> cuya
definición incorporen el tag <code>kernel.cache_clearer</code>.</p>

<p>En otras palabras.</p>

<p>``` yml
services:</p>

<pre><code>my_cache_clearer:
    class: Acme\MainBundle\Cache\MyClearer
    tags:
        - { name: kernel.cache_clearer }
</code></pre>

<p>```</p>

<p>Encontraréis mas información y especificación de estos tags
<a href="http://symfony.com/doc/current/reference/dic_tags.html#kernel-cache-clearer">aqui</a>.</p>

<h2>Reflexión</h2>

<p>En realidad es importante fijarse en la opción <code>--no-warmup</code> ya que es la que
cambia el comportamiento del comando. Cuando trabajamos en entornos de
producción, necesitamos que, en tiempo de deploy, nuestra aplicación tenga el
mínimo tiempo de downtime. Esto se consigue reduciendo al máximo el tiempo en
que una caché está vacía.</p>

<h3>Tabla básica de tiempos</h3>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1</li>
<li>[1-3] Deploy S1 &ndash;> S2</li>
<li>[3-4] Clear cache C1 from /cache</li>
<li>[4-7] Warm up new cache C2 into /cache_new</li>
<li>[7-8] Swap cache C1 &ndash;> C2. Rename /cache_new to /cache</li>
<li>[8]   Repository status: S2, Cache status: C2</li>
</ul>
</blockquote>

<h3>Problema 1</h3>

<p>Entre los tiempos 3 y 8, tenemos que /cache está vacía. Tenemos que tener en
cuenta que estamos en un entorno de producción, por lo que mientras hacemos el
proceso de deployment, nuestros servidores deben estar sirviendo peticiones en
todo momento.</p>

<p>Dado este caso, cada una de las peticiones se dará cuenta que la caché está
vacía, por lo que intentará volverla a montar desde cero. Deberíamos tener en
cuenta, entonces, que entre los tiempos 3 y 8, nuestro servicio estará caido.</p>

<p>De este análisis sacamos que debemos minimizar al máximo el tiempo pasado entre
el clear de la caché a invalidar y el switch a la nueva, o sea, reducir este
intervalo en el que nuestra caché está vacía.</p>

<p>Hace pocos dias propuse un
<a href="https://github.com/symfony/symfony/pull/9930">PR a FrameworkBundle</a> para
gestionar esto.</p>

<p>Lo único que hace es cambiar el orden entre el warm up de la nueva caché y el
clear de la vieja.</p>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1</li>
<li>[1-3] Deploy S1 &ndash;> S2</li>
<li>[3-6] Warm up new cache C2 into /cache_new</li>
<li>[6-7] Clear cache C1 from /cache</li>
<li>[7-8] Swap cache C1 &ndash;> C2. Rename /cache_new to /cache</li>
<li>[8]   Repository status: S2, Cache status: C2</li>
</ul>


<p>Downtime 2</p></blockquote>

<p>En este punto podemos ver que la ventana que separa el clear de la caché antigua
y el switch con la nueva solo es de dos unidades de tiempo, entre los tiempos 6
y 8. Ahora se nos plantea otro problema.</p>

<h3>Problema 2</h3>

<p>Hemos minimizado al máximo el tiempo de switch entre las dos caches, pero
seguimos teniendo una ventana de 5 unidades de tiempo entre que el repositorio
está en un estado S2 y la caché en un estado C1.</p>

<blockquote><p>Real downtime 5</p></blockquote>

<p>En realidad, dado este análisis solo podríamos actuar de una sola forma, y es
trabajar con un deployment paralelo ( como hace el warmup del cache:clear ).
Esto significa que nunca deployamos sobre nuestra instalación activa</p>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1 en /project</li>
<li>[1-8] Deployment Repository + cache:clear en /project_warmup</li>
<li>[8]   Repository status: S2, Cache status: C2 en /project_warmup</li>
<li>[8-9] Swap repository S1 &ndash;> S2. Rename /project to /project_warmup</li>
</ul>


<p>Downtime: 0</p></blockquote>

<h3>Problema 3</h3>

<p>En este caso es probable que nuestro proceso de deploy nos modifique elementos
externos, como puede ser ( y probablemente sea ) <code>mysql</code>. Entonces tendremos una
ventana bastante grande donde el modelo deployado en mysql que haga S2 no se
asemeje al modelo Doctrine de S1.</p>

<blockquote><p>Downtime: X</p></blockquote>

<p>So what? Como lo hacéis vosotros? Ya es por sondear un poco hacia donde tira la
gente&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic routes in Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2013/10/01/dynamic-routes-in-symfony2/"/>
    <updated>2013-10-01T18:30:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2013/10/01/dynamic-routes-in-symfony2</id>
    <content type="html"><![CDATA[<p>Given that most times we need to associate a static route entry with a method of
a controller, it is normal for Symfony developers are used to working with the
annotation @Route of FrameworkExtraBundle.</p>

<p>In some cases, it will be interesting or necessary to work with the router to
generate dynamic routes. This means that any bundle can generate a route from a
service, defining both the name of the route as all the information necessary
for the resolution of the route.</p>

<p>Consider the following example</p>

<p>``` php
&lt;?php</p>

<p>namespace Mmoreram\AcmeBundle\Router;</p>

<p>use Symfony\Component\Config\Loader\LoaderInterface;
use Symfony\Component\Config\Loader\LoaderResolverInterface;
use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\RouteCollection;</p>

<p>/<em>*
 * Acme dynamic router
 </em>/
class AcmeRoutesLoader implements LoaderInterface
{</p>

<pre><code>/**
 * @var boolean
 *
 * Route is loaded
 */
private $loaded = false;

/**
 * Loads a resource.
 *
 * @param mixed  $resource The resource
 * @param string $type     The resource type
 *
 * @return RouteCollection
 *
 * @throws RuntimeException Loader is added twice
 */
public function load($resource, $type = null)
{
    if ($this-&gt;loaded) {

        throw new \RuntimeException('Do not add this loader twice');
    }

    $routes = new RouteCollection();

    /**
     * url('controller_name') will point AcmeController:methodAction()
     */
    $routes-&gt;add('controller_name', new Route('controller/route', array(
        '_controller'   =&gt;  'AcmeBundle:Acme:method',
    )));

    $this-&gt;loaded = true;

    return $routes;
}

/**
 * Returns true if this class supports the given resource.
 *
 * @param mixed  $resource A resource
 * @param string $type     The resource type
 *
 * @return boolean This class supports the given resource
 */
public function supports($resource, $type = null)
{
    return 'acme' === $type;
}

/**
 * Gets the loader resolver.
 *
 * @return LoaderResolverInterface A LoaderResolverInterface instance
 */
public function getResolver()
{
}

/**
 * Sets the loader resolver.
 *
 * @param LoaderResolverInterface $resolver A LoaderResolverInterface
 */
public function setResolver(LoaderResolverInterface $resolver)
{
}
</code></pre>

<p>}
```</p>

<p>In method <code>supports()</code>, <code>$type</code> value can be any desired value, and only should
be defined once in all project.</p>

<p>As any service, we must define this class in dependency injection with specific
tag.</p>

<p>``` yml
services:</p>

<pre><code>acme.routes.loader:
    class: Mmoreram\AcmeBundle\Router\AcmeRoutesLoader
    tags:
        - { name: routing.loader }
</code></pre>

<p>```</p>

<p>And finally we just need to make our project know where to build our route, so
in <code>routing.yml</code> file we must add these lines.</p>

<p>``` yml
acme_routes:</p>

<pre><code>resource: .
type: acme
</code></pre>

<p>```</p>

<blockquote><p>At this point, type value must be the same as defined in Router service.</p></blockquote>
]]></content>
  </entry>
  
</feed>
