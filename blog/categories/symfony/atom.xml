<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Symfony | Because yes]]></title>
  <link href="http://mmoreram.github.io/blog/categories/symfony/atom.xml" rel="self"/>
  <link href="http://mmoreram.github.io/"/>
  <updated>2014-01-03T15:24:29+01:00</updated>
  <id>http://mmoreram.github.io/</id>
  <author>
    <name><![CDATA[Marc Morera]]></name>
    <email><![CDATA[yuhu@mmoreram.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cache clear en Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2014/01/03/cache-clear-en-symfony2/"/>
    <updated>2014-01-03T15:11:00+01:00</updated>
    <id>http://mmoreram.github.io/blog/2014/01/03/cache-clear-en-symfony2</id>
    <content type="html"><![CDATA[<p>Vacía la caché de Symfony, y la vuelve a crear ( sino se especifica lo contrario )</p>

<p><code>bash
$ php app/console cache:clear [--no-warmup] [--no-optional-warmers]
</code></p>

<p>Curioso comando existente en el framework Symfony2 desde sus inicios, y poco utilizado por los proyectos. En realidad, he visto pocos proyectos que utilizen este comando en los scripts de deploy, por lo que lo más habitual que veremos es el clásico</p>

<p><code>bash
$ rm -Rf app/cache/*
</code></p>

<p>Pero es correcta esta práctica? Aunque parezca la forma más ágil de limpiar cache, tengamos en cuenta que Symfony2 tiene procesos internos que muchos de nosotros desconocemos por completo. Cuando ejecutamos el comando para vaciar caché ( con la opción <code>--no-warmup</code> ) no tan solo vaciamos el directorio caché sino que el framework ejecuta el método <code>clear()</code> de todos los servicios que implementan la interface <code>Symfony\Component\HttpKernel\CacheClearer\CacheClearerInterface</code> cuya definición incorporen el tag <code>kernel.cache_clearer</code>.</p>

<p>En otras palabras.</p>

<p>``` yml
services:</p>

<pre><code>my_cache_clearer:
    class: Acme\MainBundle\Cache\MyClearer
    tags:
        - { name: kernel.cache_clearer }
</code></pre>

<p>```</p>

<p>Encontraréis mas información y especificación de estos tags <a href="http://symfony.com/doc/current/reference/dic_tags.html#kernel-cache-clearer">aqui</a>.</p>

<h2>Reflexión</h2>

<p>En realidad es importante fijarse en la opción <code>--no-warmup</code> ya que es la que cambia el comportamiento del comando. Cuando trabajamos en entornos de producción, necesitamos que, en tiempo de deploy, nuestra aplicación tenga el mínimo tiempo de downtime. Esto se consigue reduciendo al máximo el tiempo en que una caché está vacía.</p>

<h3>Tabla básica de tiempos</h3>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1</li>
<li>[1-3] Deploy S1 &ndash;> S2</li>
<li>[3-4] Clear cache C1 from /cache</li>
<li>[4-7] Warm up new cache C2 into /cache_new</li>
<li>[7-8] Swap cache C1 &ndash;> C2. Rename /cache_new to /cache</li>
<li>[8]   Repository status: S2, Cache status: C2</li>
</ul>
</blockquote>

<h3>Problema 1</h3>

<p>Entre los tiempos 3 y 8, tenemos que /cache está vacía. Tenemos que tener en cuenta que estamos en un entorno de producción, por lo que mientras hacemos el proceso de deployment, nuestros servidores deben estar sirviendo peticiones en todo momento.</p>

<p>Dado este caso, cada una de las peticiones se dará cuenta que la caché está vacía, por lo que intentará volverla a montar desde cero. Deberíamos tener en cuenta, entonces, que entre los tiempos 3 y 8, nuestro servicio estará caido.</p>

<p>De este análisis sacamos que debemos minimizar al máximo el tiempo pasado entre el clear de la caché a invalidar y el switch a la nueva, o sea, reducir este intervalo en el que nuestra caché está vacía.</p>

<p>Hace pocos dias propuse un <a href="https://github.com/symfony/symfony/pull/9930">PR a FrameworkBundle</a> para gestionar esto.</p>

<p>Lo único que hace es cambiar el orden entre el warm up de la nueva caché y el clear de la vieja.</p>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1</li>
<li>[1-3] Deploy S1 &ndash;> S2</li>
<li>[3-6] Warm up new cache C2 into /cache_new</li>
<li>[6-7] Clear cache C1 from /cache</li>
<li>[7-8] Swap cache C1 &ndash;> C2. Rename /cache_new to /cache</li>
<li>[8]   Repository status: S2, Cache status: C2</li>
</ul>


<p>Downtime 2</p></blockquote>

<p>En este punto podemos ver que la ventana que separa el clear de la caché antigua y el switch con la nueva solo es de dos unidades de tiempo, entre los tiempos 6 y 8. Ahora se nos plantea otro problema.</p>

<h3>Problema 2</h3>

<p>Hemos minimizado al máximo el tiempo de switch entre las dos caches, pero seguimos teniendo una ventana de 5 unidades de tiempo entre que el repositorio está en un estado S2 y la caché en un estado C1.</p>

<blockquote><p>Real downtime 5</p></blockquote>

<p>En realidad, dado este análisis solo podríamos actuar de una sola forma, y es trabajar con un deployment paralelo ( como hace el warmup del cache:clear ). Esto significa que nunca deployamos sobre nuestra instalación activa</p>

<blockquote><ul>
<li>[1]   Repository status: S1, Cache status: C1 en /project</li>
<li>[1-8] Deployment Repository + cache:clear en /project_warmup</li>
<li>[8]   Repository status: S2, Cache status: C2 en /project_warmup</li>
<li>[8-9] Swap repository S1 &ndash;> S2. Rename /project to /project_warmup</li>
</ul>


<p>Downtime: 0</p></blockquote>

<h3>Problema 3</h3>

<p>En este caso es probable que nuestro proceso de deploy nos modifique elementos externos, como puede ser ( y probablemente sea ) <code>mysql</code>. Entonces tendremos una ventana bastante grande donde el modelo deployado en mysql que haga S2 no se asemeje al modelo Doctrine de S1.</p>

<blockquote><p>Downtime: X</p></blockquote>

<p>So what? Como lo hacéis vosotros? Ya es por sondear un poco hacia donde tira la gente&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic routes in Symfony2]]></title>
    <link href="http://mmoreram.github.io/blog/2013/10/01/dynamic-routes-in-symfony2/"/>
    <updated>2013-10-01T18:30:00+02:00</updated>
    <id>http://mmoreram.github.io/blog/2013/10/01/dynamic-routes-in-symfony2</id>
    <content type="html"><![CDATA[<p>Given that most times we need to associate a static route entry with a method of a controller, it is normal for Symfony developers are used to working with the annotation @Route of FrameworkExtraBundle.</p>

<p>In some cases, it will be interesting or necessary to work with the router to generate dynamic routes. This means that any bundle can generate a route from a service, defining both the name of the route as all the information necessary for the resolution of the route.</p>

<p>Consider the following example</p>

<p>``` php
&lt;?php</p>

<p>namespace Mmoreram\AcmeBundle\Router;</p>

<p>use Symfony\Component\Config\Loader\LoaderInterface;
use Symfony\Component\Config\Loader\LoaderResolverInterface;
use Symfony\Component\Routing\Route;
use Symfony\Component\Routing\RouteCollection;</p>

<p>/<em>*
 * Acme dynamic router
 </em>/
class AcmeRoutesLoader implements LoaderInterface
{</p>

<pre><code>/**
 * @var boolean
 *
 * Route is loaded
 */
private $loaded = false;

/**
 * Loads a resource.
 *
 * @param mixed  $resource The resource
 * @param string $type     The resource type
 *
 * @return RouteCollection
 *
 * @throws RuntimeException Loader is added twice
 */
public function load($resource, $type = null)
{
    if ($this-&gt;loaded) {

        throw new \RuntimeException('Do not add this loader twice');
    }

    $routes = new RouteCollection();

    /**
     * url('controller_name') will point AcmeController:methodAction()
     */
    $routes-&gt;add('controller_name', new Route('controller/route', array(
        '_controller'   =&gt;  'AcmeBundle:Acme:method',
    )));

    $this-&gt;loaded = true;

    return $routes;
}

/**
 * Returns true if this class supports the given resource.
 *
 * @param mixed  $resource A resource
 * @param string $type     The resource type
 *
 * @return boolean true if this class supports the given resource, false otherwise
 */
public function supports($resource, $type = null)
{
    return 'acme' === $type;
}

/**
 * Gets the loader resolver.
 *
 * @return LoaderResolverInterface A LoaderResolverInterface instance
 */
public function getResolver()
{
}

/**
 * Sets the loader resolver.
 *
 * @param LoaderResolverInterface $resolver A LoaderResolverInterface instance
 */
public function setResolver(LoaderResolverInterface $resolver)
{
}
</code></pre>

<p>}
```</p>

<p>In method <code>supports()</code>, <code>$type</code> value can be any desired value, and only should be defined once in all project.</p>

<p>As any service, we must define this class in dependency injection with specific tag.</p>

<p>``` yml
services:</p>

<pre><code>acme.routes.loader:
    class: Mmoreram\AcmeBundle\Router\AcmeRoutesLoader
    tags:
        - { name: routing.loader }
</code></pre>

<p>```</p>

<p>And finally we just need to make our project know where to build our route, so in <code>routing.yml</code> file we must add these lines.</p>

<p>``` yml
acme_routes:</p>

<pre><code>resource: .
type: acme
</code></pre>

<p>```</p>

<blockquote><p>At this point, type value must be the same as defined in Router service.</p></blockquote>
]]></content>
  </entry>
  
</feed>
